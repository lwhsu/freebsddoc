<!--
     The FreeBSD Documentation Project
     Translated into Chinese by Isaac Weng <cwweng@mail.ep.nctu.edu.tw>
     $FreeBSD: doc/zh/big5/handbook/ports/chapter.sgml,v 1.5 2003/08/02 05:34:39 statue Exp $
     English Version : 1.76
-->

<chapter id="ports">
  <title>安裝應用軟體：The Ports collection</title>

  <para><emphasis>Rewritten by &a.jim;, 22 November 1999.  Original work
    by various people.</emphasis></para>

  <sect1>
    <title>概要</title>

    <para>FreeBSD Ports collection 使得編譯及安裝大範圍的應用程式輕而易舉。
      </para>

    <para>一般而言，它是一群 <link linkend="ports-skeleton">skeletons</link>
      的組合，其包含了使應用程式在 FreeBSD 上俐落地編譯及安裝所需的最小項目。
      </para>

    <para>即使有開放性標準的宣傳，要讓一個程式在各種 Unix
      上跑起來是個棘手的工程。偶然地你可能會發現所要的程式在系統上乾淨的編譯，
      把所有東西安裝到正確的目錄，而且&ldquo;像剛出廠的一樣&rdquo;跑的完美無瑕，
      不過這是相當罕見的。多數時候，你會發現為了使程式能工作自己必須做些修改。
      這就是 FreeBSD Ports collection 要拯救之處。</para>

    <para>Ports collection
      背後一般的想法就是要消除與讓東西適當地工作有關的所有雜亂的步驟，
      這樣安裝就變得簡單且毫無痛苦。有了 Ports collection，
      所有困難的工作都幫你搞定了，而且只要打 <command>make install</command>
      就可以安裝 Ports collection 裡任一個 port。</para>
  </sect1>
  
  <sect1 id="ports-using">
    <title>使用 Ports Collection</title>

    <para>下面的章節提供了一些基本的指引，指導使用 ports collection
      來從系統安裝或移除程式。</para>

    <sect2 id="ports-skeleton">
      <title>安裝 Ports</title>

      <para>當提到 Ports collection 第一個要說明的就是何謂 &ldquo;skeleton&rdquo;。
	簡而言之，一個 port skeleton 是讓一個程式在 FreeBSD
        上簡潔地編譯並安裝所需的檔案的最小組合，每個 port skeleton 包含：</para>

      <itemizedlist>
	<listitem>
	  <para>一個 <filename>Makefile</filename>。<filename>Makefile</filename>
            包含多種敘述，這些敘述指示一個應用程式在系統上應如何編譯和安裝到何處。</para>
	</listitem>

	<listitem>
	  <para>一個 <filename>files</filename> 目錄。目錄
            <filename>files</filename> 包含一個名為 <filename>md5</filename>
            的檔案。這個檔案是以用來決定 port checksum 的 MD5 演算法命名。
	    Checksum 是一個由合計所要檢查的檔案資料所產生的數字。
	    如果任何字母改變了，checksum 就會和原本的不同並顯示錯誤訊息，
            如此一來便可以調查哪邊改變了。</para>

	  <para>目錄 <filename>files</filename> 也可以有其它 port
            需要但不屬於其他目錄結構的檔案。</para>
	</listitem>

	<listitem>
	  <para>一個 <filename>patches</filename> 目錄。
            這個目錄包含了使程式在 FreeBSD 系統上編譯和安裝的 patch。
	    Patch 基本上是小檔案，用以指示要改變特定的檔案。
            它們是純文字檔格式，基本上說的是 &ldquo;Remove line 10&rdquo; 或
            &ldquo;Change line 26 to this ...&rdquo;。Patch 也以
            &ldquo;diffs&rdquo; 聞名，因為它們是由
            <application>diff</application> 這個程式產生。</para>
	</listitem>

	<listitem>
	  <para>一個 <filename>pkg</filename> 目錄。這個目錄通常包含三個檔案。
	    偶爾會有這三個以外的檔案，不過要視 port 而定。大部份只需要這三個。
	    這三個檔案是：</para>

	  <itemizedlist>
	    <listitem>
	      <para><filename>COMMENT</filename>。這是一行對程式的描述。</para>
	    </listitem>

	    <listitem>
	      <para><filename>DESCR</filename>。
                這往往是對程式更詳細而且多行的描述。</para>
	    </listitem>

	    <listitem>
	      <para><filename>PLIST</filename>。這是 port
                將安裝的所有檔案的列表。它也告訴了 port
                的系統當反安裝時所要移除的檔案。</para>
	    </listitem>
	  </itemizedlist>
	</listitem>
      </itemizedlist>

      <para>現在已經有足夠的背景資訊來了解 ports collection 用來做什麼，
        準備好要安裝第一個 port 了。有兩個辦法可以完成這件事，
        每一個都會在後面解釋。</para>

      <para>然而在我們進入前，必須選擇一個 port 來安裝。
        有一些辦法可以達成這件事，最簡單的是 <ulink
	url="http://www.freebsd.org/ports/">FreeBSD 網站上的 ports
        名單</ulink>。可以把列在那裡的 ports 瀏覽一下或用站上的搜尋功能。
	每個 port 也包括一份描述以便在決定安裝前可以稍微看看。</para>

      <para>另一個方法是用 <command>whereis</command> 這個命令。
        要用 <command>whereis</command> 只要在提式符號後打
        &ldquo;<command>whereis &lt;要安裝的程式&gt;&rdquo;</command>，
        如果系統裡有找到它，便會告訴你它在哪裡，就像：</para>

      <screen>&prompt.root; <userinput>whereis xchat</userinput>
xchat: /usr/ports/irc/xchat
&prompt.root;</screen>

      <para>這告訴我們 xchat (一個 irc client) 可以在目錄
        <filename>/usr/ports/irc/xchat</filename> 找到。</para>

      <para>尚有另一個方法找尋特定的 port 就是用 ports collection
        內建的搜尋機制。要用這個搜尋的特色必須在目錄
        <filename>/usr/ports</filename> 下。一旦在這個目錄，執行
	<command>make search key=program-name</command>，
	&ldquo;program-name&rdquo; 是要找的程式的名稱。例如，
	如果要找 xchat：</para>

      <screen>&prompt.root; <userinput>cd /usr/ports</userinput>
&prompt.root; <userinput>make search key=xchat</userinput>
Port:   xchat-1.3.8
Path:   /usr/ports/irc/xchat
Info:   An X11 IRC client using the GTK+ toolkit, and optionally, GNOME
Maint:  jim@FreeBSD.org
Index:  irc
B-deps: XFree86-3.3.5 bzip2-0.9.5d gettext-0.10.35 giflib-4.1.0 glib-1.2.6 gmake-3.77 gtk-1.2.6
		imlib-1.9.8 jpeg-6b png-1.0.3 tiff-3.5.1
R-deps: XFree86-3.3.5 gettext-0.10.35 giflib-4.1.0 glib-1.2.6 gtk-1.2.6 imlib-1.9.8 jpeg-6b
		png-1.0.3 tiff-3.5.1</screen>

      <para>這部份輸出要特別注意的是 &ldquo;Path:&rdquo; 那行，
        因為那告訴你去哪找。其它提供的資訊對於安裝 port 並沒有直接地需要，
        所以這裡不會含蓋那部份。</para>

      <note>
        <para>必須是 <username>root</username> 才能安裝 port。</para>
      </note>

      <para>現在你已經找到想要安裝的 port，準備好真正的安裝了。</para>

      <sect3 id="ports-cd">
        <title>從光碟安裝 port</title>

        <para>如同你從標題的猜測，這個章節所敘述的所有事物都假設已經有一套
	  FreeBSD 光碟。如果沒有可以從 <ulink
	  url="http://www.freebsdmall.com/">FreeBSD Mall</ulink>
          訂購。</para>

        <para>假設 FreeBSD 光碟已經放入光碟機且掛在 <filename>/cdrom</filename>
          上(掛上點<emphasis>必須</emphasis>是 <filename>/cdrom</filename>)，
	  那就準備好要安裝 port 了。開始前先把目錄換到要安裝的 port
          所在的目錄：</para>

        <screen>&prompt.root; <userinput>cd /usr/ports/irc/xchat</userinput></screen>

        <para>一但進入了 xchat 的目錄，將會看到 port skeleton。
	  下一個步驟就是編譯(也叫做建立)該 port。只要在提式符號下鍵入
	  <command>make</command> 就完成了。一旦做完這些應該就可看到如下畫面：
	  </para>

        <screen>&prompt.root; <userinput>make</userinput>
&gt;&gt; xchat-1.3.8.tar.bz2 doesn't seem to exist on this system.
&gt;&gt; Attempting to fetch from file:/cdrom/ports/distfiles/.
===&gt;  Extracting for xchat-1.3.8
&gt;&gt; Checksum OK for xchat-1.3.8.tar.bz2.
===&gt;   xchat-1.3.8 depends on executable: bzip2 - found
===&gt;   xchat-1.3.8 depends on executable: gmake - found
===&gt;   xchat-1.3.8 depends on shared library: gtk12.2 - found
===&gt;   xchat-1.3.8 depends on shared library: Imlib.5 - found
===&gt;   xchat-1.3.8 depends on shared library: X11.6 - found
===&gt;  Patching for xchat-1.3.8
===&gt;  Applying FreeBSD patches for xchat-1.3.8
===&gt;  Configuring for xchat-1.3.8
...
[剪去了 configure 的輸出]
...
===&gt;  Building for xchat-1.3.8
...
[剪去了編譯過程]
...
&prompt.root;</screen>

        <para>注意一旦編譯完成就會回到提示符號。下一步就是安裝 port。
	  要安裝它只需在命令 <command>make</command> 後加上
	  <command>install</command>：</para>

        <screen>&prompt.root; <userinput>make install</userinput>
===&gt;  Installing for xchat-1.3.8
===&gt;   xchat-1.3.8 depends on shared library: gtk12.2 - found
===&gt;   xchat-1.3.8 depends on shared library: Imlib.5 - found
===&gt;   xchat-1.3.8 depends on shared library: X11.6 - found
...
[剪以了去安裝的例行步驟]
...
===&gt;   Generating temporary packing list
===&gt;   Installing xchat docs in /usr/X11R6/share/doc/xchat
===&gt;   Registering installation for xchat-1.3.8
&prompt.root;</screen>

        <para>一旦回到提示符號下應該就可以執行剛安裝完的應用程式。</para>

        <note>
          <para>只要執行 <command>make install</command> 代替
            <command>make</command> 和 <command>make install</command>
            這兩個分開的步驟就可以省下額外的步驟。</para>
        </note>

        <note>
          <para>請注意有些 port 的授權並不允許 port 被包含在光碟裡。
            這有許多種原因，包括下載前需要填註冊表格的，假如不允許再散佈的等等。
	    如果希望安裝光碟裡沒有的 port，必須在線上才能做到(看<link
	      linkend="ports-inet">下一章</link>)。</para>
        </note>
      </sect3>

      <sect3 id="ports-inet">
      <title>從網路安裝 port</title>

        <para>如同上一節，這一節假設已經有個能用的網路連線。
          如果沒有就必須做<link linkend="ports-cd">光碟安裝</link>。</para>

        <para>從網路安裝 port 的做法跟從光碟安裝沒有兩樣。
          兩者間唯一不同的就是程式的程式碼是從網路下載而非從光碟取得。</para>

        <para>有關的步驟是相同的：</para>

        <screen>&prompt.root; <userinput>make install</userinput>
&gt;&gt; xchat-1.3.8.tar.bz2 doesn't seem to exist on this system.
&gt;&gt; Attempting to fetch from http://xchat.org/files/v1.3/.
Receiving xchat-1.3.8.tar.bz2 (305543 bytes): 100%
305543 bytes transferred in 2.9 seconds  (102.81 Kbytes/s)
===&gt;  Extracting for xchat-1.3.8
&gt;&gt; Checksum OK for xchat-1.3.8.tar.bz2.
===&gt;   xchat-1.3.8 depends on executable: bzip2 - found
===&gt;   xchat-1.3.8 depends on executable: gmake - found
===&gt;   xchat-1.3.8 depends on shared library: gtk12.2 - found
===&gt;   xchat-1.3.8 depends on shared library: Imlib.5 - found
===&gt;   xchat-1.3.8 depends on shared library: X11.6 - found
===&gt;  Patching for xchat-1.3.8
===&gt;  Applying FreeBSD patches for xchat-1.3.8
===&gt;  Configuring for xchat-1.3.8
...
[剪去了 configure 的輸出]
...
===&gt;  Building for xchat-1.3.8
...
[剪去了編譯過程]
...
===&gt;  Installing for xchat-1.3.8
===&gt;   xchat-1.3.8 depends on shared library: gtk12.2 - found
===&gt;   xchat-1.3.8 depends on shared library: Imlib.5 - found
===&gt;   xchat-1.3.8 depends on shared library: X11.6 - found
...
[剪去了去安裝的例行步驟]
...
===&gt;   Generating temporary packing list
===&gt;   Installing xchat docs in /usr/X11R6/share/doc/xchat
===&gt;   Registering installation for xchat-1.3.8
&prompt.root;</screen>

        <para>如你所見，唯一的不同是告訴你去哪裡取得 port 那行。</para>

        <para>前面做的是有關安裝 port 到系統上。
          在這節將會學到如何從系統上移除一個 port。</para>
      </sect3>
    </sect2>

    <sect2 id="ports-removing">
      <title>移除已安裝的 Port</title>

      <para>現在你已經知道如何安裝 port，那很可能會很好奇要如何移除它們，
        只為了預防安裝了一個 port 過沒多久才決定說裝錯了。
        下面幾段將確實地含蓋這些。</para>

      <para>現在我們將移除先前的例子(對那些沒在注意的人來多就是 xchat 啦)。
        如同安裝 port，第一件要做的就是切換到 port 的目錄，如果有記得就是
	<filename>/usr/ports/irc/xchat</filename>。
        切換完目錄後就準備好可以反安裝 xchat 了。用命令
	<command>make deinstall</command> 可以完成(有道裡吧？)：</para>

      <screen>&prompt.root; <userinput>cd /usr/ports/irc/xchat</userinput>
&prompt.root; <userinput>make deinstall</userinput>
===&gt;  Deinstalling for xchat-1.3.8
&prompt.root;</screen>

      <para>這樣就夠容易了。現在你已經可以應付從系統裡移除 xchat 了。
        如果想要再安裝它，可以在目錄
        <filename>/usr/ports/irc/xchat</filename> 下執行
        <command>make reinstall</command> 來完成。</para>
    </sect2>
  </sect1>

  <sect1 id="ports-trouble">
    <title>Troubleshooting</title>

    <para>接下來這節包括了一些有關 ports collection 常被問的問題和一些基本的
      troubleshooting 技巧，還有假如 <link linkend="ports-broken">port
      有毛病</link>該怎麼做。</para>

    <sect2 id="ports-questions">
      <title>一些問題和答覆</title>

      <qandaset>
        <qandaentry>
	  <question>
	  <para>這是在討論 modem 吧？！</para>
	  </question>

	  <answer>
	  <para>啊，你一定是想到電腦背後的串列埠了。&ldquo;port&rdquo;
            在這是指把一個程式從一種版的 UNIX &ldquo;移植(porting)&rdquo;
            到另一種版本的結果。</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	  <para>應該用 package 來安裝額外的程式嗎？</para>
	  </question>

	  <answer>
	  <para>沒錯，那是最快最容易的辦法。</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	  <para>那為什麼用 port 來困擾人呢？</para>
	  </question>

	  <answer>
	  <para>有幾個原因：</para>

	  <orderedlist>
	    <listitem>
	      <para>有些軟體發行的授權禁止以 binary 散佈。
                它們必須以程式碼散佈。</para>
	    </listitem>

	    <listitem>
	      <para>有些人不信任 binary 的發行版本。
                至少有程式碼可以自己瞧瞧有沒有潛藏的問題(理論上)。</para>
	    </listitem>

	    <listitem>
	      <para>如果有自己的 patch，要提供它們就必須有程式碼。</para>
	    </listitem>

	    <listitem>
	      <para>你可能和做好 package 的人在編譯程式方面有不同的意見 &mdash;
                有些人在最佳化的設定上有強烈的觀點，
                不論是否是建立可除錯的版本再把它分開等等..</para>
	    </listitem>

	    <listitem>
	      <para>有些人喜歡有原始碼在身邊，這樣當無聊的時後可以拿來讀讀，
                拿來 hack，借些點子(當然要版權許可！)和諸如此類的。</para>
	    </listitem>

	    <listitem>
	      <para>If you ain't got the source, it ain't software!
		<!-- smiley -->;-)</para>
	    </listitem>
	  </orderedlist>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	  <para id="ports-patch">什麼是 patch？</para>
	  </question>

	  <answer>
	  <para>Patch 是一個宣告如何把檔案改成另一種版本的小檔案。
	    它包含純文字，而且基本上說明了類似 &ldquo;delete line 23&rdquo;，
	    &ldquo;add these two lines after line 468&rdquo; 或是
	    &ldquo;change line 197 to this&rdquo; 的事情。它們也以 diff
            聞名因為它們是由 <application>diff</application>
            這個程式產生。</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	  <para id="ports-tarball">Tarball 是指什麼？</para>
	  </question>

	  <answer>
	  <para>它是一個以 <filename>.tar</filename> 結尾的檔案，
            或是其它種類，諸如 <filename>.tar.gz</filename>，
            <filename>.tar.Z</filename>，<filename>.tar.bz2</filename>，
	    甚至是 <filename>.tgz</filename>。</para>

	  <para>基本上它只是一個被包成檔案(<filename>.gz</filename>)的目錄，
            或是選擇性的壓縮起來(<filename>.gz</filename>)。
            這個技巧是來自於使用 <emphasis>T</emphasis>ape
            <emphasis>AR</emphasis>chives(所以叫做 <command>tar</command>)，
            不過被廣泛的應用於在網路上散佈程式。</para>

	  <para>可以自己看看裡面有什麼檔案，或是用陽春版 FreeBSD 系統
            內附的標準 Unix 的 tar 程式把它解開來，就像這樣：</para>

	  <screen>&prompt.user; <userinput>tar tvzf foobar.tar.gz</userinput>
&prompt.user; <userinput>tar xzvf foobar.tar.gz</userinput>
&prompt.user; <userinput>tar tvf foobar.tar</userinput>
&prompt.user; <userinput>tar xvf foobar.tar</userinput></screen>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	  <para id="ports-checksum">那 checksum 呢？</para>
	  </question>

	  <answer>
	  <para>這是一個由合計想檢查的檔案裡所有的資料所產生的數字。
            如果有任何字元改變了，那 checksum 就不會再跟合計的結果一樣，
            所以經由簡單的比較就可以偵察出差異。</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	  <para>我照之前說的方法從光碟編譯 port 都很順，
            怎麼一要安裝 kermit 就出槌？</para>

	  <screen>&prompt.root; <userinput>make install</userinput>
&gt;&gt; cku190.tar.gz doesn't seem to exist on this system.
&gt;&gt; Attempting to fetch from ftp://kermit.columbia.edu/kermit/archives/.</screen>

	  <para>為什麼找不到？難道這張光碟沒有用？</para>
	  </question>

	  <answer>
	  <para>就像在<link linkend="ports-cd">從光碟編譯 ports</link>
            那節所解釋的，有些 port 因為授權的限制不能放進光碟。Kermit
            就是個例子。Kermit 的授權不允許把為它做的 tarball 放進光碟，
            所以必須自己動手抓回來 &mdash; 真是抱歉！</para>

	  <para>會有這些錯誤訊息是因為當時沒有連上網路。一旦從 MASTER_SITES
            (列在 Makefile 裡)中所列的任一個站把檔案抓下來，
            就可以重新開始安裝的步驟了。</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	  <para>我照做了，可是當要把檔案放進
            <filename>/usr/ports/distfiles</filename> 卻得到沒有許可的錯誤訊息。
	    </para>
	  </question>

	  <answer>
	  <para>Port 的機制是到 <filename>/usr/ports/distfiles</filename>
            找 tarball，可是因為它是符號連結(symlink)到光碟的，
            所以那個目錄唯讀而且也沒有辦法複製任何東西進去。
            用下面說的方法就可以叫它去找其它地方：</para>

	  <screen>&prompt.root; <userinput>make DISTDIR=<replaceable>/where/you/put/it</replaceable> install</userinput></screen>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	  <para>Ports 的設計是只有把所有東西都放在
	    <filename>/usr/ports</filename> 下才能用嗎？
            系統管理員說要把所有東西都放在 <filename>/u/people/guests/wurzburger</filename>
            下，不過這樣好像不能用。</para>
	  </question>

	  <answer>
	  <para>可以用 <makevar>PORTSDIR</makevar> 和
	    <makevar>PREFIX</makevar> 這兩個變數來告訴 port 用別的目錄。
            例如，</para>

	  <screen>&prompt.root; <userinput>make PORTSDIR=/u/people/guests/wurzburger/ports install</userinput></screen>

	  <para>會在 <filename>/u/people/guests/wurzburger/ports</filename>
            裡編譯 port 並把所有東西安裝在 <filename>/usr/local</filename>
            下。</para>

	  <screen>&prompt.root; <userinput>make PREFIX=/u/people/guests/wurzburger/local install</userinput></screen>

	  <para>會在 <filename>/usr/ports</filename> 裡編譯 port 並安裝至
	    <filename>/u/people/guests/wurzburger/local</filename>。</para>

	  <para>毫無疑問的，</para>

	  <screen>&prompt.root; <userinput>make PORTSDIR=.../ports PREFIX=.../local install</userinput></screen>

	  <para>會結合這兩種(要在這頁完整的寫出來太長了，
            不過它應該給你點概略了)。</para>

	  <para>如果不想每次安裝一個 port 就要把這些字再特別打一次，
            把這設定放到環境變數裡會是個好主意。讀讀 shell 的 man page
            來獲得做這些事的指引。</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	  <para>我並沒有 FreeBSD 的光碟，不過我想要有所有的 tarball 在手邊，
            這樣就不用每次裝一個 port 就要等待下載。
            有什麼好方法可以一次全抓下來嗎？</para>
	  </question>

	  <answer>
	  <para>要拿到 ports collection 每個 tarball 的話，執行：</para>

	  <screen>&prompt.root; <userinput>cd /usr/ports</userinput>
&prompt.root; <userinput>make fetch</userinput></screen>

	  <para>要拿到 port 某個目錄下全部的 tarball 的話，執行：</para>

	  <screen>&prompt.root; <userinput>cd /usr/ports/<replaceable>directory</replaceable></userinput>
&prompt.root; <userinput>make fetch</userinput></screen>

	  <para>只要一個的話 &mdash; 嗯，我想你應該早猜到了。</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	  <para>我知道從臨近的 FreeBSD mirror 站抓比較快。
            可是有辦法從其它 MASTER_SITES 上面沒有的站抓 port 嗎？</para>
	  </question>

	  <answer>
	  <para>可以啊。如果知道的話，例如 <hostid
	    role="fqdn">ftp.FreeBSD.org</hostid> 比
	    <makevar>MASTER_SITES</makevar> 上面列的任何站都近，
            那就這麼做：</para>

	  <screen>&prompt.root; <userinput>cd /usr/ports/<replaceable>directory</replaceable></userinput>
&prompt.root; <userinput>make MASTER_SITE_OVERRIDE=ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/distfiles/ fetch</userinput></screen>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	  <para>要怎樣在 <command>make</command> 去抓檔案前先知道所需的檔案？</para>
	  </question>

	  <answer>
	  <para><command>make fetch-list</command> 會列出一個 port
            所需的檔案。</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	  <para>有辦法在 port 編譯前停止嗎？我想在它安裝前 hack 一下程式碼，
            不過每次都要邊看邊按 control-C 很討厭。</para>
	  </question>

	  <answer>
            <para>用 <command>make extract</command>
              會在原始碼抓完並解開後停止。</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	  <para>我想試試做個自己的 port 並在有機會看看我的 patch
            是否成功前停止編譯。有像 <command>make extract</command>
            的指令不過是針對 patch 的嗎？</para>
	  </question>

	  <answer>
	  <para>有，<command>make patch</command> 就是了。
            <makevar>PATCH_DEBUG</makevar> 這個選項也一樣好用。
            順帶一提，多謝你的努力！</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	  <para>聽說有些編譯器的選項會造成錯誤。真的嗎？
            怎麼確定用來編譯 port 的設定是正確的呢？</para>
	  </question>

	  <answer>
	  <para>是的，除非也有 <option>-fno-strength-reduce</option>
            這個選項，否則 <command>gcc</command> 2.6.3 版(跟著 FreeBSD 2.1.0
            和 2.1.5 一起出貨的版本)用 <option>-O2</option>
            這個選項會造成有錯誤的程式碼。(大部份的 port 沒有用
            <option>-O2</option> 這個選項)。
            <emphasis>應該</emphasis>可以用下面的方法指定編譯器的選項</para>

	  <screen>&prompt.root; <userinput>make CFLAGS='-O2 -fno-strength-reduce' install</userinput></screen>

	  <para>或是藉由編輯 <filename>/etc/make.conf</filename>，
            不幸地並不是所有的 port 都聽它的話。最穩當的方法是先執行
            <command>make configure</command>，然後到原始碼的目錄手動檢視
            <filename>Makefile</filename>，不過如果有很多子目錄，
            而每個子目錄也有自己的 <filename>Makefile</filename>
            做起來就很冗長乏味。</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	  <para>這麼多 port 害我很難找到我想要的。有可以取得的 port 的列表嗎？</para>
	  </question>

	  <answer>
	  <para>看一看 <filename>/usr/ports</filename> 裡的
            <filename>INDEX</filename> 檔吧。如果要用關鍵字找的話，
            也可以這麼做。例如要找和 LISP 這個程式語言有關的 port 就用：</para>

	  <screen>&prompt.user; <userinput>cd /usr/ports</userinput>
&prompt.user; <userinput>make search key=lisp</userinput></screen>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	  <para>怎麼原本要裝的 <literal>foo</literal> 裝到一半停下來跑去裝
            <literal>bar</literal>？這是怎麼一回事？</para>
	  </question>

	  <answer>
	  <para><literal>foo</literal> 這個 port 需要一些由
            <literal>bar</literal>提供的東西 &mdash; 舉個例子，假如
            <literal>foo</literal> 會用到圖形，<literal>bar</literal>
            可能有個函式庫包含很多有用的圖形處理程式。或者
            <literal>bar</literal> 可能是編譯 <literal>foo</literal>
            所需的工具。</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	  <para id="ports-remove">我從 port 裡裝了 <literal>grizzle</literal>，
            坦白說它很浪費空間。我想要把它砍掉可是不知道檔案放在哪裡。
            有線索嗎？</para>
	  </question>

	  <answer>
	  <para>沒問題，只要這樣做：</para>

	  <screen>&prompt.root; <userinput>pkg_delete grizzle-6.5</userinput></screen>

	  <para>還有一個方法就是：</para>

	  <screen>&prompt.root; <userinput>cd <replaceable>/usr/ports/somewhere/grizzle</replaceable></userinput>
&prompt.root; <userinput>make deinstall</userinput></screen>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	  <para>等一下，這必須知道程式的版本才能用這個指令。
            該不會真的希望我把它記下來吧？</para> 
	  </question>

	  <answer>
	  <para>一點也不，照著下面做就可以找到：</para>

	  <screen>&prompt.root; <userinput>pkg_info -a | grep grizzle</userinput>Information for grizzle-6.5:
grizzle-6.5 - the combined piano tutorial, LOGO interpreter and shoot 'em up arc
ade game.</screen>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	  <para>說到了磁碟空間，ports 的目錄似乎佔去了嚇人的空間。
            跑到目錄裡去刪除東西安全嗎？</para>
	  </question>

	  <answer>
	  <para>是的，如果程式已經裝好而且相當確定不會再用到原始檔，
            那就沒有理由把它留在那裡閒晃。要這樣做最好的方法就是：</para>

	  <screen>&prompt.root; <userinput>cd /usr/ports</userinput>
&prompt.root; <userinput>make clean</userinput></screen>

	  <para>這樣就會仔細檢查每個 port 的子目錄並且刪除 skeleton
            以外的所有東西。</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	  <para>我照做了，可是那個隨便你怎麼稱呼它的 tarball
            還是在<filename>目錄 distfiles</filename>裡。
            可以把那些也砍了嗎？</para>
	  </question>

	  <answer>
	  <para>是的，如果確定它們已經沒利用價值，那就可以讓它們安心的走了。
             可以手動移除或是用 <command>make distclean</command>。</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	  <para>數以百計的程式我都想拿來玩看看。有辦法一次裝完全部的 port 嗎？
            </para>
	  </question>

	  <answer>
	  <para>只要執行：</para>

	  <screen>&prompt.root; <userinput>cd /usr/ports</userinput>
&prompt.root; <userinput>make install</userinput></screen>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	  <para>好吧，我試了，不過我以為會花很長的時間所以先跑去睡了，
            讓它自己繼續下去。不過今天早上看電腦時，它只做好了三個半的
            port。有哪裡出錯了嗎？</para>
	  </question>

	  <answer>
	  <para>不是，是因為有的 port 需要問一些問題但我們不能幫忙回答
            (例如&ldquo;要印在 A4 或 US 信件大小的紙上？rdquo;)
            而且需要有人在旁邊回答。</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	  <para>我實在很不想整天盯著螢幕看。有更好的主意嗎？</para>
	  </question>

	  <answer>
	  <para>OK，在你 上床/工作/去公園 前做這件事：</para>

	  <screen>&prompt.root <userinput>cd /usr/ports</userinput>
&prompt.root; <userinput>make -DBATCH install</userinput></screen>

	  <para>這樣會把<emphasis>不</emphasis>需要使用者做輸入的
            port 都裝好。然後等回來後再執行：</para>

	  <screen>&prompt.root; <userinput>cd /usr/ports</userinput>
&prompt.root; <userinput>make -DIS_INTERACTIVE install</userinput></screen>

	  <para>來完成這件事。</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	  <para>在工作上我們要用到 ports collection 裡的
            <literal>frobble</literal>，不過我們已經修改了很多以符合所需。
            有辦法做自己的 package 嗎？
            這樣才能更容易的在我們的站上散佈這些 port。</para>
	  </question>

	  <answer>
	  <para>沒問題，假設已經知道如何對所做的改變做出 patch：</para>

	  <screen>&prompt.root; <userinput>cd <replaceable>/usr/ports/somewhere/frobble</replaceable></userinput>
&prompt.root; <userinput>make extract</userinput>
&prompt.root; <userinput>cd work/frobble-2.8</userinput>
[提供你的 patches]
&prompt.root; <userinput>cd ../..</userinput>
&prompt.root; <userinput>make package</userinput></screen>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	  <para>Port 好聰明。真想確定這怎麼做到的。秘訣在哪呢？</para>
	  </question>

	  <answer>
	  <para>一點都不神秘，只要看看<ulink
              url="file://localhost/usr/ports/Mk/">目錄 makefiles</ulink> 裡
            的 <filename>bsd.port.mk</filename> 和
            <filename>bsd.port.subdir.mk</filename> 這兩個檔。</para>

	  <para>(建議對 shell-scripts 有股莫名的厭惡的人不要看這個連結...)</para>
	  </answer>
	</qandaentry>
      </qandaset>
    </sect2>

    <sect2 id="ports-broken">
      <title>救命啊！這個 port 故障了(broken)！</title>

      <para>如果遇到了自己不能用的 port，這有幾個可做的事，包括：</para>

      <orderedlist>
        <listitem>
	  <para>修正它！<link linkend="porting">&ldquo;如何做一個
	    port&rdquo;</link> 這節應該會有所幫助。</para>
	</listitem>

	<listitem>
	  <para>訴苦吧 &mdash;<emphasis>只能用 email！</emphasis>首先寄
	    email 給 port 的 maintainer。鍵入 <command>make
	    maintainer</command> 或是看 <filename>Makefile</filename>
	    來找 maintainter 的電子郵件地址。記得把 port 的名稱和版本也包括進去
	    (<filename>Makefile</filename> 裡
            <literal>$FreeBSD:</literal> 那行)和出現錯誤前的輸出訊息一併寄給
            maintainer)。如果沒有從 maintainer 得到回應，可以用
            <command>send-pr</command> 的命令把 bug 回報。</para>
	</listitem>

	<listitem>
	  <para>忘了它。這是最簡單的途徑了 &mdash; ports
          裡的程式很少有被分類為&ldquo;不可或缺的&rdquo;。
          當 port 更新到下一個版本時，任何問題都將很有可能會修好。</para>
	</listitem>

	<listitem>
	  <para>從臨近的 ftp 站抓 package。Package collection 的
	    &ldquo;主站&rdquo;在 FreeBSD 的 FTP 伺服器 <hostid
	    role="fqdn">ftp.FreeBSD.org</hostid> 的 <ulink
	    URL="ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/packages/">目錄
            packages</ulink> 下，不過請<emphasis>第一個</emphasis>看看當地的
            mirror 站有沒有。這些 packages 比試著從原始碼編譯更有希望能執行，
            而且更快！用 &man.pkg.add.1; 這個程式來把 package 裝到系統上。</para>
	</listitem>
      </orderedlist>
    </sect2>
  </sect1>

  <sect1 id="porting">
    <title>進階專題</title>

    <sect2>
      <title>自己做個 port</title>

      <para>想必現在各位一定對做一個自己的 port 和升級現有的 port
        有興趣吧？太棒了！</para>

      <para>接下來的是如何做一個 FreeBSD 的 port 的指引。
        如果要升級現有的 port 就應該看完這個再看
        <xref linkend="port-upgrading">。</para>

      <para>覺得這份文件不夠詳細時，可以參考所有 port 的
        <filename>Makefile</filename> 都有包含的
        <filename>/usr/ports/Mk/bsd.port.mk</filename>。即使沒有每天都在
        hack Makefile，仍然建議這樣做，而且可以從裡面得到很多知識。
        此外也可以把特別的問題送到 &a.ports;。</para>

      <note>
        <para>只有少數可以更動的變數
          (<makevar><replaceable>VAR</replaceable></makevar>)
          才會在這份文件中提到。大部份(如果不是全部)都在
          <filename>bsd.port.mk</filename> 的開始有註解。
          這個檔案用的是不標準的 tab 設定。<application>Emacs</application>
          和 <application>Vim</application> 在載入檔案時應該都能辯認出來。
          一旦檔案載入時，<command>vi</command> 和 <command>ex</command>
          都能藉由鍵入 <command>:set tabstop=4</command> 得到正確的設定值。
          </para>
      </note>
    </sect2>

    <sect2 id="quick-porting">
      <title>快速 Porting</title>

      <para>這一章說明了如何快速地移植(port)。
        不過我們會看到在很多地方這樣是不夠的。</para>

      <para>首先拿到原始的 tarball 並把它放進 <makevar>DISTDIR</makevar>，
        預設是 <filename>/usr/ports/distfiles</filename>。</para>

      <note>
        <para>The following assumes that the software compiled out-of-the-box,
          就是說這個 port 完全不需要修改就可以在 FreeBSD 上執行。
          假如要改變某個地方，那也必須參考下一節。</para>
      </note>

      <sect3>
        <title>撰寫 <filename>Makefile</filename></title>

        <para>最小的 <filename>Makefile</filename> 看起來會是這副德性：</para>

        <programlisting>
# New ports collection makefile for:   oneko
# Version required:    1.1b
# Date created:        5 December 1994
# Whom:                asami
#
# &dollar;FreeBSD&dollar;
#
       
DISTNAME=      oneko-1.1b
CATEGORIES=    games
MASTER_SITES=  ftp://ftp.cs.columbia.edu/archives/X11R5/contrib/
       
MAINTAINER=    asami@FreeBSD.org
       
MAN1=          oneko.1
MANCOMPRESSED= yes
USE_IMAKE=     yes
       
.include &lt;bsd.port.mk&gt;</programlisting>

        <para>看能不能了解吧。不用擔心有 <literal>&dollar;FreeBSD&dollar;</literal>
          那行，當 port 進入主要的 port tree 時會由 CVS 自動填上。
          可以在 <link linkend="porting-samplem">Makefile
          的樣本</link>那章裡有更詳細的例子。</para>
      </sect3>

      <sect3>
        <title>撰寫敘述(description)檔</title>

        <para>有三個敘述檔是每個 port 都要有的，不管它們實際上是不是 package。
          這三個檔是 <filename>COMMENT</filename>，<filename>DESCR</filename>
          和 <filename>PLIST</filename>，並放在 <filename>pkg</filename>
          這個子目錄裡。</para>

        <sect4>
          <title><filename>COMMENT</filename></title>

          <para>這個檔僅用一行來描述 port。<emphasis>拜托</emphasis>不要把
            package 的名稱也寫進去(或是軟體的版本)。
            這份註解應該以大寫字母開頭，而結尾不能有英文的句點。
            這裡有一個範例：</para>

          <programlisting>
A cat chasing a mouse all over the screen</programlisting>
        </sect4>

        <sect4>
          <title><filename>DESCR</filename></title>

          <para>這是一個較長的敘述。
            用一到幾段的敘述簡潔扼要的說明 port 的事是足夠的。</para>

          <note>
            <para>這並<emphasis>不是</emphasis>一份關於如何使用或編譯 port
              的指南或深入的描述！<emphasis>如果直接從
              <filename>README</filename> 或 manpage</emphasis>
              抄過來的話請慎重；因為太多時後它們並不是個扼要的說明，
              或者它們的格式很難應付(如 manpage 有調整過的 spacing)。
              如果被移植的軟體有正式的 WWW 首頁，那也應該列在這個檔案裡。
              在<emphasis>一個</emphasis>網站的字首加上
              <literal>WWW:</literal> 這樣自動化的工具才能正確地執行。</para>
          </note>

          <para>建議在檔案的最後寫上自己的名字，如下：</para>

          <programlisting>
This is a port of oneko, in which a cat chases a poor mouse all over
the screen.
 :
(etc.)

WWW: http://www.oneko.org/            

- Satoshi
asami@cs.berkeley.edu</programlisting>
        </sect4>

        <sect4>
          <title><filename>PLIST</filename></title>

          <para>這個檔案列出了所有 port 安裝的檔案。因為 package
            就是藉由把所列出的檔案包裝起來產生的，所以這個檔又叫做
            &ldquo;packing list&rdquo;。其路徑則是相對於安裝的前置目錄(通常是
            <filename>/usr/local</filename> 或
            <filename>/usr/X11R6</filename>)。如果有用
            <makevar>MAN<replaceable>n</replaceable></makevar>
            這個變數(本來就該這麼做)，那千萬不要在這裡列出任何 manpage。</para>

          <para>這裡有個小例子：</para>

          <programlisting>
bin/oneko
lib/X11/app-defaults/Oneko
lib/X11/oneko/cat1.xpm
lib/X11/oneko/cat2.xpm
lib/X11/oneko/mouse.xpm
@dirrm lib/X11/oneko</programlisting>

          <para>詳細資料參考 &man.pkg.create.1; man page
            裡的包裝列表(packing list)。</para>

          <note>
            <para>列表裡應該列出所有的檔案，而不是 the name directories。
              如果 port 在安裝過程自己新增了目錄，確定要有加上
              <literal>@dirrm</literal> 這幾行，因為要移除 port
              時不可或缺。</para>

            <para>建議把檔案名稱照字母順序排列。這樣在升級 port
              時可以更容易看出哪裡改變了。</para>

            <para>自己手動做一個包裝列表是很冗長乏味的。如果 port
              要裝很多檔案，那<link linkend="porting-autoplist">自動產生包裝列表</link>
              可能會較省時。</para>
          </note>
        </sect4>
      </sect3>

      <sect3>
        <title>產生 checksum file</title>

        <para>只要鍵入 <command>make makesum</command>。Port
          編譯的規則會自動產生 <filename>files/md5</filename> 這個檔。</para>
      </sect3>

      <sect3 id="porting-testing">
        <title>測試 port</title>

        <para>先確定 port 的規則都遵君旨意，包括包裝 port。
          這些都是得先確認的要點。</para>

        <itemizedlist>
          <listitem>
            <para><filename>PLIST</filename> 沒有包含任何 port 沒裝的東西</para>
          </listitem>

          <listitem>
            <para><filename>PLIST</filename> 包含 port 安裝的所有東西</para>
          </listitem>

          <listitem>
            <para>Port 可以用 <maketarget>reinstall</maketarget>
              的標的重覆安裝</para>
          </listitem>

          <listitem>
            <para>Port 在解除安裝後可以<link
                linkend="porting-cleaning">清理乾淨</link></para>
          </listitem>
        </itemizedlist>

        <procedure>
          <title>建議的測試順序</title>

          <step>
            <para><command>make install</command></para>
          </step>

          <step>
            <para><command>make package</command></para>
          </step>

          <step>
            <para><command>make deinstall</command></para>
          </step>

          <step>
            <para><command>pkg_add <replaceable>package-name</replaceable>
              </command></para>
          </step>

          <step>
            <para><command>make deinstall</command></para>
          </step>

          <step>
            <para><command>make reinstall</command></para>
          </step>

          <step>
            <para><command>make package</command></para>
          </step>
        </procedure>

        <para>確定 port 在 <maketarget>package</maketarget> 和
          <maketarget>deinstall</maketarget> 的階段沒有任何警告訊息，
          在步驟三後檢查是否所有新的目錄都被正確的刪除。還有，
          試著在步驟四後使用這個軟體以確定當用 package
          安裝後可以正確的執行。</para>
      </sect3>

      <sect3 id="porting-portlint">
        <title>用 <command>portlint</command> 檢查 port</title>

        <para>請用 <command>portlint</command> 來看看 port
          有沒有符合我們的指示。<command>portlint</command> 這個程式也是
          ports collection 的一部份。特別是當想用來檢查 <link
            linkend="porting-samplem">Makefile</link> 長得正不正確和
          <link linkend="porting-pkgname">package</link>
          的命名是否恰當時。</para>
      </sect3>

      <sect3 id="porting-submitting">
        <title>提出 port</title>

        <para>首先要確定已經看過<link
            linkend="porting-dads">做與不做</link>的章節。</para>

        <para>現在你一定對自己的 port 感到興奮吧，
          再來唯一要做的就是把它放到主要的 FreeBSD ports tree 裡去，
          讓其他人也同樣感到高興。我們不需要 <filename>work</filename>
          這個目錄或是 <filename>pkgname.tgz</filename> 的 package，
          所以砍了它吧。再來，只要把執行 <command>shar `find port_dir`</command>
          產生的訊息也包括進來，用 &man.send-pr.1; 以 bug
          報告的形式寄出(參考 &lt;link linkend="contrib-general"&gt; bug
          報告和一般說明&lt;/link&gt;以得到更多有關 &man.send-pr.1; 的資訊)。
          如果 port 沒壓縮前大於 20KB，
          那就要在把它包括到 bug 報告前先壓成 tar 的檔案形式並且執行
          &man.uuencode.1;(即使 bug 報告比 20KB 小也是可以把它壓起來再
          uuencoded，不過並不鼓勵)。要確定把 bug 報告分類為
          <literal>ports</literal> 而且等級為
          <literal>change-request</literal>。
          (千萬不要標記為<literal>機密</literal>報告！)</para>

        <para>再說一次，<emphasis>不要包括原始檔，目錄
            <filename>work</filename>，和用 <command>make package</command>
            做出來的 package</emphasis>。</para>

        <note>
          <para>以前建議說把新 port 上傳到 ftp 站
            (<hostid role="fqdn">ftp.FreeBSD.org</hostid>)。
            不過因為 <filename>incoming/</filename>
            這個目錄的讀取權限被關掉，所以這個方法已經不管用了。
            這是因為有太多的非法軟體出現在裡面的關係。</para>
        </note>

        <para>我們會檢視這個 port 並把它放進 ports tree，若必要的話會把它歸還。
          你的名字也會出現在 FreeBSD 使用者手冊&ldquo;額外的 FreeBSD
          貢獻者&rdquo;的列表和其它檔案裡。帥吧？！<!-- smiley -->:-)</para>
      </sect3>
    </sect2>

    <sect2>
      <title>慢慢 Porting</title>

      <para>好吧。這沒有那麼簡單，而且這個 port 需要一些修改才能工作。
        在這章裡我們用將 port 的範例一步步的解釋如何修改它才能用。</para>

      <sect3>
        <title>這些東西如何運作的</title>

        <para>首先，這是當在 port 的目錄下鍵入 <command>make</command>
          後的結果的順序，而且你可以把 <filename>bsd.port.mk</filename>
          開在另一個視窗，和這份文件配合著看，這樣比較好懂。</para>

        <para>不用擔心看不懂 <filename>bsd.port.mk</filename> 在做什麼，
          也沒很多人懂 ...<!-- smiley --><emphasis>:-&gt;</emphasis></para>

        <procedure>

          <step>
            <para><maketarget>fetch</maketarget> 這個標的正在執行。
              <maketarget>fetch</maketarget> 這個標的負責確定 tarball
              有在 <makevar>DISTDIR</makevar> 裡。如果
              <maketarget>fetch</maketarget> 在 <makevar>DISTDIR</makevar>
              找不到它要的檔案，它會去 <filename>Makefile</filename> 裡定義的
              <makevar>MASTER_SITES</makevar> 裡的 URL 找，
              正如同我們主要的 ftp 站 <ulink
                url="ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/distfiles/">
              ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/distfiles/</ulink>
              裡放著認可的檔案做為備份。假如所請求的站可以在網路上直接存取，
              它會試著用 <makevar>FETCH</makevar> 去抓指名的發行版本。
              如果成功就會把檔案存在 <makevar>DISTDIR</makevar>
              以便繼續進行和再利用。</para>
          </step>

          <step>
            <para><maketarget>extract</maketarget> 這個標的正在執行。
              它會找放在 <makevar>DISTDIR</makevar> 裡的發行版本的檔案
              (一般是 gzip 的 tarball) 並把它解到 <makevar>WRKDIR</makevar>
              所寫的暫時目錄下(預設是 <filename>work</filename>)。</para>
          </step>

          <step>
            <para><maketarget>patch</maketarget> 這個標的正在執行。首先，
              施行任何定義在 <makevar>PATCHFILES</makevar> 裡的 patch。
              再來，照字母順序施行任何在 <makevar>PATCHDIR</makevar>
              (預設是子目錄 <filename>patches</filename>)。</para>
          </step>

          <step>
            <para><maketarget>configure</maketarget> 這個標的正在執行。
              它可以從很多不一樣的事裡挑任何一個來做。</para>

            <orderedlist>
              <listitem>
                <para>如果存在 <filename>scripts/configure</filename>，
                  就執行它。</para>
              </listitem>

              <listitem>
                <para>如果設定了 <makevar>HAS_CONFIGURE</makevar>
                  或 <makevar>GNU_CONFIGURE</makevar>，
                  就執行 <filename><makevar>WRKSRC</makevar>/configure</filename>。</para>
              </listitem>

              <listitem>
                <para>如果設定了 <makevar>USE_IMAKE</makevar>，
                  執行 <makevar>XMKMF</makevar>(預設值：
                  <command>xmkmf -a</command>)。</para>
              </listitem>
            </orderedlist>
          </step>

          <step>
            <para><maketarget>build</maketarget> 正在執行。
              這個負責往下延伸進到 port 私人的工作目錄
              (<makevar>WRKSRC</makevar>)並開始編譯。
              如果設定了 <makevar>USE_GMAKE</makevar>，
              就會使用 GNU <command>make</command>，
              否則就會用系統的 <command>make</command>。</para>
          </step>
        </procedure>

        <para>上面這些是預設的動作。也可以定義額外的標的
          <maketarget>pre-<replaceable>something</replaceable></maketarget> 或
          <maketarget>post-<replaceable>something</replaceable></maketarget>，
          或是把 scripts 換這這些名字放到子目錄 <filename>scripts</filename>
          裡，這樣它們就會在預設的動做完成前或完成後執行。</para>

        <para>例如有一個叫做 <maketarget>post-extract</maketarget>的標的定義在
          <filename>Makefile</filename> 裡，和一個叫做
          <filename>pre-build</filename> 的檔案放在子目錄
          <filename>scripts</filename> 裡，那麼
          <maketarget>post-extract</maketarget> 這個標的會在規定的解開
          (extraction)動作完成後被呼叫，而
          <filename>pre-build</filename> 這個 script
          會在預設的編譯規則前執行。假如動作夠簡單的話，
          建議用 <filename>Makefile</filename> 裡的標的，
          因為這樣別人比較容易發現這個 port 需要哪些非預設的動作。</para>

        <para>這些預設的動作是由在 <filename>bsd.port.mk</filename> 的標的
          <maketarget>do-<replaceable>something</replaceable></maketarget>
          來執行。例如，用來解開一個 port 的指令寫在
          <maketarget>do-extract</maketarget> 這個標的裡。
          如果看這個預設的標的不高興的話，可以在 <filename>Makefile</filename>
          裡重新定義 <maketarget>do-<replaceable>something</replaceable></maketarget>
          來修改它。</para>

        <note>
          <para>&ldquo;主要的&rdquo;標的(如
            <maketarget>extract</maketarget>，<maketarget>configure</maketarget>
            等等)只是用來確定到這之前的階段已經完成，並呼叫真正的標的或 script，
            而且我們並沒有打算改變這些標的。假如要修改解開這個動作，請修改
            <maketarget>do-extract</maketarget>，絕不要碰
            <maketarget>extract</maketarget>！</para>
        </note>

        <para>現在應該知道當鍵入 <command>make</command> 會發生什麼了吧，
          讓我們繼續看看創造一個完美的 port 所建議的步驟吧。</para>
      </sect3>

      <sect3>
        <title>取得原始程式碼</title>

        <para>(通常)取得壓縮形式的原始碼的 tarball 
          (<filename><replaceable>foo</replaceable>.tar.gz</filename> 或
          <filename><replaceable>foo</replaceable>.tar.Z</filename>)
          並把它複製到 <makevar>DISTDIR</makevar>。
          有辦法的話就都用<emphasis>主流的</emphasis>程式碼。</para>

        <para>如果找不到連線狀況良好的 ftp/http 網站，
          或是只找得到格式不標準的站，
          可以把它複製一份放在可信任的 ftp 站或是自己控制的 http 伺服器
          (例如自己網頁)。確定所設定的 <makevar>MASTER_SITES</makevar> 
          能反應到所選擇的網站。</para>

        <para>如果找不到方便或可信賴的地方放 distfile (如果你是 FreeBSD
          committer，只要放在自己在 <hostid>freefall</hostid> 的
          <filename>public_html/</filename> 目錄裡即可)，
          最後手段就是我們會把它&ldquo;收藏&rdquo;在
          <filename>ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/distfiles/LOCAL_PORTS/</filename>。
          請參考 <makevar>MASTER_SITE_LOCAL</makevar> 所在的位置。
          <makevar>MASTER_SITE_LOCAL</makevar>。如果不確定要怎麼做到話，
          寄封信到 &a.ports; 吧。</para>

        <para>如果 port 的 distfile 經常沒理由的改來改去的話，
          可以考慮把 distfile 放在你的網頁上並把位址列為第一個
          <makevar>MASTER_SITES</makevar>。這樣可以避免讓使用者得到
          <errorname>checksum mismatch</errorname> 的錯誤訊息，
          也讓我們 ftp 站的 maintainers 輕鬆點。如果這個 port
          只有一個主要的站，建議你收藏一份備份在自己的站並列為第二個
          <makevar>MASTER_SITES</makevar>。</para>

        <para>如果這個 port 需要一些額外的 `patches' 且可以在網路上取得，
          也把它們抓下來放到 <makevar>DISTDIR</makevar> 吧。
          別擔心它門跟主要的程式碼的 tarball 來源不同，
          我們有辦法處理(看下面 <link
            linkend="porting-patchfiles">PATCHFILES</link> 的描述吧)。</para>
      </sect3>

      <sect3>
        <title>修改 port</title>

        <para>把 tarball 解到一個私人的目錄下再做任何必要的改變
          使得 port 可以在 current 版本的 FreeBSD 正確的編譯。
          <emphasis>仔細地追蹤</emphasis>所有過程，這樣才能簡短地把過程自動化。
          當 port 完成時，所有東西包括對檔案的刪除、增加，
          或是修改都要能藉由一個自動化的 script 或是 patch 檔來執行。</para>

        <para>如果該 port 需要使用者做重要的互動/定製才能編譯或安裝，
          那就該看看 Larry Wall's 的經典作之一
          <application>Configure</application> scripts，
          可能的話並自己做些相似的事。新 port 收集的目的在讓最終的使用者
          用最少的空間盡可能地做到 &ldquo;plug-and-play&rdquo;。</para>

        <note>
          <para>除非有明白的宣告，否則所有創造和貢獻給 FreeBSD ports
            收集的 patch 檔、scripts和其它的檔案都受到標準 BSD
            版權條約的保護。</para>
        </note>
      </sect3>

      <sect3>
        <title>Patching</title>

        <para>在準備 port 時，已經被增加或修改的檔案可以用一個遞迴的 diff
          整理起來以為了之後用來 patch。所要提供的每一組 patch
          都應該收集成一個叫做
          <filename>patch-<replaceable>xx</replaceable></filename>
          的檔案，<replaceable>xx</replaceable> 表示所要提供的 patch
          的順序 &mdash; 以<emphasis>字母順序</emphasis>，因此
          <literal>aa</literal> 排第一個，再來是 <literal>ab</literal> 等等。
          這些檔案應該存放在 <makevar>PATCHDIR</makevar>
          這樣才能被自動提供。所有的 patch 應該相對於 <makevar>WRKSRC</makevar>
          (通常是把 tarball 解開的目錄，編譯也在那裡完成)。
          要讓修正和升級容易的話，應該避免讓超過一個 patch 修正同一個檔案
          (例如 <filename>patch-aa</filename> 和 <filename>patch-ab</filename>
          都修正 <filename><makevar>WRKSRC</makevar>/foobar.c</filename>)。
          </para>
      </sect3>

      <sect3>
        <title>Configuring</title>

        <para>把任何附加的 customization 命令包含到 <filename>configure</filename> script
          裡並存在子目錄 <filename>scripts</filename> 裡。
          正如同前面提過的，也可以藉由 <filename>Makefile</filename>
          裡的標的和/或以 <filename>pre-configure</filename> 或
          <filename>post-configure</filename> 命名的 script
          來做到這件事。</para>
      </sect3>

      <sect3>
        <title>處理使用者的輸入</title>

        <para>如果 port 需要使用者輸入以編譯，configuration，或安裝，那就在
          Makefile 裡設定 <makevar>IS_INTERACTIVE</makevar>。
          這樣會允許設定環境變數 <envar>BATCH</envar>
          的使用者在&ldquo;徹夜編譯&rdquo;時跳過這個
          port (如果使用者設了變數 <envar>INTERACTIVE</envar>，
          那就<emphasis>只有</emphasis>需要互動的程式會被編譯)。</para>

        <para>同樣地，假如有合理的預設答案，則建議當變數
          <makevar>PACKAGE_BUILDING</makevar> 設定時關掉那個互動的 script。
          這樣便允許我們為光碟和 ftp 編譯 packages。</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Configuring the Makefile</title>

      <para>Configuring the Makefile 相當簡單，
        再次建議你在開始前看看現有的例子。
        使用手冊裡也有一個 <link linkend="porting-samplem">Makefile
        的樣品</link>，所以看看並跟隨著樣品裡變數和章節的順序，
        讓你的 port 對別人來說更具可讀性。</para>

      <para>現在，在設計新的 Makefile 時依序考慮下面的問題吧：</para>

      <sect3>
        <title>原始程式碼</title>

        <para>它有以標準 gzip 的 tarball 形式放在
          <makevar>DISTDIR</makevar> 嗎？如果有，跳到下一步吧。如果沒有，
          檢視 port 發行的檔案是哪種星球的格式來決定要用
          <makevar>EXTRACT_CMD</makevar>，
          <makevar>EXTRACT_BEFORE_ARGS</makevar>，
          <makevar>EXTRACT_AFTER_ARGS</makevar>，
          <makevar>EXTRACT_SUFX</makevar>，或 <makevar>DISTFILES</makevar>
          中的任一變數。(當 tarball 被標準的壓縮程式而不是 gzip 壓縮時，
          最常見的格式是
          <literal>EXTRACT_SUFX=.tar.Z</literal>。)</para>

        <para>在最糟的情況下，可以簡單的創造一個自己的
          <maketarget>do-extract</maketarget> 標的來蓋過預設的，
          雖然這很少見，但如果出現就只得這麼做了。</para>
      </sect3>

      <sect3>
        <title><makevar>DISTNAME</makevar></title>

        <para>把 <makevar>DISTNAME</makevar> 設為 port 的名稱。
          預設的規定是希望發行版本的檔案列表以
          <makevar>DISTNAME</makevar><makevar>EXTRACT_SUFX</makevar>
          的形式命名，對一個正常的 tarball 而言，
          一個名為 <literal>DISTNAME=foozolix-1.0</literal>
          的 port，其檔案列表應該長得像 <literal>foozolix-1.0.tar.gz</literal>。
          </para>

        <para>預設的規則也期望把 tarball(s) 解到子目錄
          <filename>work/<makevar>DISTNAME</makevar></filename> 下，
          如 <filename>work/foozolix-1.0/</filename>。</para>

        <para>當然這些都可以被推翻；它只是代表了大部份省時的共同預設值。
          對一個需要多個發行版本的檔案的 port，只要明確的設定
          <makevar>DISTFILES</makevar>即可。如果只有一小組
          <makevar>DISTFILES</makevar> 是實際可解開的檔案，
          那就把它們寫在 <makevar>EXTRACT_ONLY</makevar>，
          這樣當要解開時便會取代 <makevar>DISTFILES</makevar> 的列表，
          而其它的檔案則會留在 <makevar>DISTDIR</makevar> 以後再用。</para>
      </sect3>

      <sect3>
        <title><makevar>PKGNAME</makevar></title>

        <para>如果 <makevar>DISTNAME</makevar> 不符合 <link
            linkend="porting-pkgname">好的 package 名稱的指南</link>，
          那就設定 <makevar>PKGNAME</makevar> 這個變數來取個好名字吧。
          要知道更多細節就看上面那個指南吧。</para>
      </sect3>

      <sect3>
        <title><makevar>CATEGORIES</makevar></title>

        <para>當一個 package 做好時，它會放在
          <filename>/usr/ports/packages/All</filename>
          下並連結到 <filename>/usr/ports/packages</filename>
          下的一個或多個子目錄。這些子目錄的名稱在變數
          <makevar>CATEGORIES</makevar> 裡有詳細說明。
          這是打算讓使用者在 ftp 站或光碟上費力渡過一堆 package
          來找東西時容易一點。請看一下現有的<link
            linkend="porting-categories">分類(category)</link>並選一個最適合你的
          port 的。</para>

        <para>這也決定了 port 會被收入到 port tree 的位置。
          如果在這變數裡放進了太多的分類，將假設 port
          的檔案會被放在第一個分類的子目錄裡。<link
            linkend="porting-categories">分類</link>這個章節裡有更多關於如何
          挑選正確的分類的討論。</para>

        <para>如果 port 真的不屬於現有的任何分類，就自己創造一個吧。
          在這情況下請寄封信到 &a.ports; 提議一個新的分類。</para>

        <note>
          <para>檢查種類名稱時不會有任何錯誤。如果打錯種類名稱，<command>make
              package</command> 會很樂意幫你生出一個新目錄，
            所以要小心點！</para>
        </note>
      </sect3>

      <sect3>
        <title><makevar>MASTER_SITES</makevar></title>

        <para>把 ftp/http-URL 裡指出來源 tarball 所在目錄的部份記錄在
          <makevar>MASTER_SITES</makevar>裡。
          別忘了跟在後面的斜線 (<filename>/</filename>)！</para>

        <para>如果在系統裡找不到發行版本的檔案的話，<command>make</command>
          這個巨集指令在用 <makevar>FETCH</makevar>
          抓檔時會試著用到這份清單。</para>

        <para>建議在列表裡放多一點站，最好來自各洲。
          這樣會避免大範圍的網路問題，我們甚至計畫增加可自動決定最近的
          主站並從那裡抓取的支援！</para>

        <para>如果來源的 tarball 是下面幾個普遍的檔案庫：
          X-contrib，GNU，Perl CPAN，TeX CTAN，或 Linux Sunsite，
          可以利用 <makevar>MASTER_SITE_XCONTRIB</makevar>，
          <makevar>MASTER_SITE_GNU</makevar>，
          <makevar>MASTER_SITE_PERL_CPAN</makevar>，
          <makevar>MASTER_SITE_TEX_CTAN</makevar>，和
          <makevar>MASTER_SITE_SUNSITE</makevar> 來做參考。只要把 
          <makevar>MASTER_SITE_SUBDIR</makevar> 設到檔案庫裡的路徑。
          這有個例子：</para>

        <programlisting>
MASTER_SITES=         ${MASTER_SITE_XCONTRIB}
MASTER_SITE_SUBDIR=   applications</programlisting>

        <para>使用者也可在 <filename>/etc/make.conf</filename>
          設定變數 <makevar>MASTER_SITE_*</makevar> 來蓋過我們的選擇，
          然後用他們喜歡的 mirror 站來代替。</para>
      </sect3>

      <sect3 id="porting-patchfiles">
        <title><makevar>PATCHFILES</makevar></title>

        <para>如果你的 port 需要一些額外的 patch，而又可以由 ftp 或
          http 取得，那就把 <makevar>PATCHFILES</makevar> 設為檔案名稱，
          而 <makevar>PATCH_SITES</makevar> 為包含該檔案的目錄的 URL
          (格式跟 <makevar>MASTER_SITES</makevar> 一樣)。</para>

        <para>假如因為 patch 包含一些額外的路徑，使得 patch
          並不相對於程式碼的樹狀結構的最上層(如 <makevar>WRKSRC</makevar>)，
          那就適當地設定 <makevar>PATCH_DIST_STRIP</makevar>。舉個例，
          假如 patch 裡所有的路徑前面都多加了
          <literal>foozolix-1.0/</literal>，那就設成
          <literal>PATCH_DIST_STRIP=-p1</literal>。</para>

        <para>別擔心 patch 被壓縮起來，如果檔案名稱是以
          <filename>.gz</filename> 或 <filename>.Z</filename> 結尾，
          那它們會自動被解壓。</para>

        <para>如果 patch 是跟其它檔案，如文件，一起以 gzip 形式的
          tarball 發行，那就不能用 <makevar>PATCHFILES</makevar>。
          在這情形下，就把 patch tarball 的名稱和位置加進
          <makevar>DISTFILES</makevar> 和 <makevar>MASTER_SITES</makevar>。
          然後，從 <maketarget>pre-patch</maketarget> 的標的提供 patch，
          不論是從那個標的執行，或是把 path 複製到目錄
          <makevar>PATCHDIR</makevar> 裡並稱之為
          <filename>patch-<replaceable>xx</replaceable></filename>。</para>

        <note>
          <para>要注意 tarball 已經跟著正常的程式碼被解開了，
            所以如果是以 gzip 或 compress 壓起來的 tarball 也不必要再解開。
            如果你把它解開了，特別小心不要把已經存在目錄裡的東西改寫掉。
            同樣也別忘了在 <maketarget>pre-clean</maketarget>
            的標的裡加個命令來移除複製的 patch。</para>
        </note>
      </sect3>

      <sect3>
        <title><makevar>MAINTAINER</makevar></title>

        <para>在這留下你的郵件地址吧。拜托 <!-- smiley
          --><emphasis>:-)</emphasis></para>

        <para>要知道有關 maintainer 負責事項詳細的描述的話，
          參考 <link linkend="policies-maintainer">MAINTAINER on
          Makefiles</link> 的章節。</para>
      </sect3>

      <sect3>
        <title>Dependencies</title>

        <para>很多 port 都依賴其它的 port。有五個變數可用來確定所有需要的
          部份都已經在使用者的機器裡了。在一般情形下還有一些預先支援的
          dependency 變數，加上了多一些東西來控制 dependency 的表現。</para>

        <sect4>
          <title><makevar>LIB_DEPENDS</makevar></title>

          <para>這個變數詳述了該 port 所依賴的共享函式。
            它是個多組 <replaceable>lib</replaceable>:<replaceable>dir</replaceable><optional><replaceable>:target</replaceable></optional>
            的列表，<replaceable>lib</replaceable> 是共享函式的名稱，
            <replaceable>dir</replaceable>
            是萬一系統裡沒有時可用來找到它的目錄，而
            <replaceable>target</replaceable> 是在那目錄下所呼叫的標的。
            例如 <programlisting> LIB_DEPENDS=
              jpeg.9:${PORTSDIR}/graphics/jpeg:install</programlisting>
            會檢查主版本為 9 的共享函式 jpeg，且假如找不到的話，
            便會往下到 ports tree 的子目錄 <filename>graphics/jpeg</filename>
            建立並安裝它。假如 <replaceable>target</replaceable> 和
            <makevar>DEPENDS_TARGET</makevar> 一樣的話則可省略(預設是
            <literal>install</literal>)。</para>

          <note>
            <para><replaceable>lib</replaceable> 的部份是一個要給
              <command>ldconfig -r | grep -wF</command> 的參數。
              在這個變數裡不可有正規表示式(regular expression)。</para>
          </note>

          <para>Denpendency 會被檢查兩次，一次是在
            <maketarget>extract</maketarget> 的標的裡，一次是在
            <maketarget>install</maketarget> 的標的。
            同樣地，dependency 的名稱也會放到 package 裡這樣當使用者系統裡沒有時
            <command>pkg_add</command> 便會自動把它裝上。</para>
        </sect4>

        <sect4>
          <title><makevar>RUN_DEPENDS</makevar></title>

          <para>這個變數詳述了這個 port 執行時所依賴的可執行檔或檔案。
            它是個多組
            <replaceable>path</replaceable>:<replaceable>dir</replaceable><optional><replaceable>:target</replaceable></optional> 的列表，
            <replaceable>path</replaceable> 是執行檔或檔案的名稱，
            <replaceable>dir</replaceable>
            是萬一系統裡沒有時可用來找到它的目錄，
            而 <replaceable>target</replaceable> 是在該目錄所呼叫的標的。
            如果 <replaceable>path</replaceable> 以短斜線開頭
            (<literal>/</literal>)，那它會被看做一個檔案並用
            <command>test -e</command> 這個命令來測試其是否存在；
            否則就認為是可執行檔並用 <command>which -s</command>
            來決定程式是否在使用者的搜尋路徑裡。</para>

          <para>例如，</para>

            <programlisting>
RUN_DEPENDS=   ${PREFIX}/etc/innd:${PORTSDIR}/news/inn \
               wish8.0:${PORTSDIR}/x11-toolkits/tk80</programlisting>

          <para>會檢查 <filename>/usr/local/etc/innd</filename>
            這個檔案或目錄是否存在，如果找不到就會去 port tree 的子目錄
            <filename>news/inn</filename> 把它建立並裝好。
            它也會看在搜尋路徑裡是否有個叫 <command>wish8.0</command>
            的可執行檔，沒找到的話就到 port tree 的子目錄
            <filename>x11-toolkits/tk80</filename> 裡建立並安裝好。</para>

          <note>
            <para>在這裡 <command>innd</command> 實際上是個可執行檔；
              如果一個可執行檔所在目錄並不是一般使用者的搜尋路徑，
              那就應該用完整的路徑表示。</para>
          </note>

          <para>Dependency 會在 <maketarget>install</maketarget>
            的標的裡檢查。同樣地，dependency 的名稱也要放到 package 裡，
            這樣當使用者的系統沒有時 <command>pkg_add</command>
            這個命令便會自動安裝它。如果 <replaceable>target</replaceable>
            的部份和 <makevar>DEPENDS_TARGET</makevar> 相同則可省略。</para>
        </sect4>

        <sect4>
          <title><makevar>BUILD_DEPENDS</makevar></title>

          <para>這個變數詳述了這個 port 編譯時需要的執行檔或檔案。
            就跟 <makevar>RUN_DEPENDS</makevar> 一樣，它是由多組
            <replaceable>path</replaceable>:<replaceable>dir</replaceable><optional><replaceable>:target</replaceable></optional> 構成的列表。
            例如<programlisting> BUILD_DEPENDS=
              unzip:${PORTSDIR}/archivers/unzip</programlisting>
            會檢查是否有個執行檔 <command>unzip</command>，
            沒有的話就到 port tree 的子目錄
            <filename>archivers/unzip</filename> 下建立並裝它。</para>

          <note>
            <para>在這裡&ldquo;建立&rdquo;指得是從解壓到編譯整個過程。
              Dependency 會在 <maketarget>extract</maketarget> 的標的裡檢查。
              假如 <replaceable>target</replaceable> 的部份跟
              <makevar>DEPENDS_TARGET</makevar> 一樣則可以省略。</para>
          </note>
        </sect4>

        <sect4>
          <title><makevar>FETCH_DEPENDS</makevar></title>

          <para>這個變數詳述在取得該 port 時所需的執行檔或檔案。
            跟前兩個一樣，它也是由多組
            <replaceable>path</replaceable>:<replaceable>dir</replaceable><optional><replaceable>:target</replaceable></optional> 組成的列表。
            例如 <programlisting> FETCH_DEPENDS=
              ncftp2:${PORTSDIR}/net/ncftp2</programlisting> 會檢查
            <command>ncftp2</command> 這個執行檔，沒有的話就到 port tree
            下的子目錄 <filename>net/ncftp2</filename> 建立並安裝它。</para>

          <para>Dependency 會在 <maketarget>fetch</maketarget>
            的標的裡檢查。假如 <replaceable>target</replaceable>
            的部份跟 <makevar>DEPENDS_TARGET</makevar>
            一樣則可省略。</para>
        </sect4>

        <sect4>
          <title><makevar>DEPENDS</makevar></title>

          <para>如果有個 dependency 不屬於上面四種之一，或是你的 port
            需要其它 port 解開的程式碼才能安裝，那就用這個變數吧。
            這是一份
            <replaceable>dir</replaceable><optional><replaceable>:target</replaceable></optional> 的列表，
            不像前面四個，這裡沒什麼好檢查的。
            如果 <replaceable>target</replaceable> 的部份跟
            <makevar>DEPENDS_TARGET</makevar> 一樣則可省略。</para>
        </sect4>

        <sect4>
          <title>一般的 dependency 變數</title>

          <para>如果 port 需要有安裝 X Window System 才能安裝，
            請定義 <literal>USE_XLIB=yes</literal>(它被包含在
            <makevar>USE_IMAKE</makevar>裡)。假如 port 需要 GNU
            <command>make</command> 以取代 BSD <command>make</command>
            ，請定義 <literal>USE_GMAKE=yes</literal>。假如 port 需要執行到 GNU
            autoconf，請定義 <literal>USE_AUTOCONF=yes</literal>。假如 port 
            要用最新的 qt toolkit，請定義 <literal>USE_QT=yes</literal>。 
            如果 port 需要第五版的 perl 程式語言，那就用
            <literal>USE_PERL5=yes</literal>。(最後一個最重要，
            因為一些版本的 FreeBSD 把 perl5 弄為陽春版的一部份，而其它的沒有。)
            </para>
        </sect4>

        <sect4>
          <title>Dependency 的注意事項</title>

          <para>在前面提過，當需要 dependency 時會呼叫的預設標的是
            <maketarget>DEPENDS_TARGET</maketarget>。預設值是
            <literal>install</literal>。這是個使用者的變數；它從未在 port
            的 <filename>Makefile</filename> 裡定義。如果 port
            需要特別的方法來處裡 dependency，用 <makevar>*_DEPENDS</makevar>
            裡 <literal>:target</literal> 的部份而不要重新定義
            <makevar>DEPENDS_TARGET</makevar>。</para>

          <para>當鍵入 <command>make clean</command>後，
            它的 dependency 也會被自動清除。如果不想清除的話，
            可以設定環境變數 <makevar>NOCLEANDEPENDS</makevar>。</para>

          <para>要無條件地依賴其它 port，照慣例是以字串
            <literal>nonexistent</literal> 為 <makevar>BUILD_DEPENDS</makevar>
            或 <makevar>RUN_DEPENDS</makevar> 的第一個欄位。只有當需要其它 port
            的程式碼時才這麼做。也可以經常用這個標的來省下編譯的時間。
            例如

            <programlisting>
BUILD_DEPENDS=   /nonexistent:${PORTSDIR}/graphics/jpeg:extract</programlisting>

            每次都會到 JPEG 這個 port 裡並解開它。</para>

          <para>除非沒有別的辦法可以完成所想要表現的，否則別用
            <makevar>DEPENDS</makevar>。它會使得其它 port 每次都被編譯(
            還有安裝，照預設值的話)，而且 dependency 也會進到 package 裡。
            如果真的需要，建議你寫成 <literal>BUILD_DEPENDS</literal> 和
            <literal>RUN_DEPENDS</literal> 代替 &mdash;
            至少這樣目的較清楚。</para>
        </sect4>
      </sect3>

      <sect3>
        <title>建立的機制</title>

        <para>如果 package 要用到 GNU <command>make</command>，設定
          <literal>USE_GMAKE=yes</literal>。如果 package 要用到
          <command>configure</command>，設定
          <literal>HAS_CONFIGURE=yes</literal>。如果 package 要用到 GNU
          <command>configure</command>，設定
          <literal>GNU_CONFIGURE=yes</literal> (這包含
          <literal>HAS_CONFIGURE</literal>)。如果要對
          <command>configure</command> 下一些額外的參數(對 GNU
          <command>configure</command> 預設參數為
          <literal>--prefix=&dollar;{PREFIX}</literal>，非 GNU
          <command>configure</command> 則無)，把這些額外的參數設在
          <makevar>CONFIGURE_ARGS</makevar> 裡。如果 package 要用到 GNU
          <command>autoconf</command>，設定
          <literal>USE_AUTOCONF=yes</literal>。這包含了
          <makevar>GNU_CONFIGURE</makevar>，而且會使
          <command>autoconf</command> 在 <command>configure</command>
          之前執行。</para>

        <para>如果 package 是用 <command>imake</command> 從
          <filename>Imakefile</filename>s 產生 <filename>Makefile</filename>s
          的 X 應用程式，就設定 <literal>USE_IMAKE=yes</literal>。
          這樣會使 configure 的階段自動做 <command>xmkmf -a</command>。
          如果 <option>-a</option> 這個旗標會對 port 造成問題，就設成
          <literal>XMKMF=xmkmf</literal>。如果 port 用<command>imake</command>
          這個命令卻又認不得 <maketarget>install.man</maketarget> 這個指標，
          那就應該設 <literal>NO_INSTALL_MANPAGES=yes</literal>。還有，
          最初的 port 的作者名字應該被記上一筆。
          <!-- smiley --><emphasis>:-&gt;</emphasis></para>

        <para>如果 port 的程式碼裡的 <filename>Makefile</filename> 以
          <maketarget>all</maketarget> 以外的標的作為主要的建立標的，
          那就設成 <makevar>ALL_TARGET</makevar>。同樣的道理也適用在
          <maketarget>install</maketarget> 和
          <makevar>INSTALL_TARGET</makevar>。</para>
      </sect3>
    </sect2>

    <sect2>
      <title>特殊考量</title>

      <para>還有一些事項是創造一個新 port 時所要考慮的。
        這個章節解釋了大部份的一般情形。</para>

      <sect3 id="porting-ldconfig">
        <title><command>ldconfig</command></title>

        <para>如果 port 安裝了一個共享函式，在 <filename>Makefile</filename>
          裡加上 <maketarget>post-install</maketarget> 這個標的，
          內容為在新函式安裝的目錄上(通常是
          <filename><makevar>PREFIX</makevar>/lib</filename>)執行
          <literal>&dollar;{LDCONFIG} -m</literal>
          以將其註冊進共享函式暫存區裡。</para>

        <para>此外，增加一對 <literal>@exec /sbin/ldconfig -m</literal> 和
          <literal>@unexec /sbin/ldconfig -R</literal> 的組合到檔案
          <filename>pkg/PLIST</filename> 裡以便安裝此 package
          的使用者可以立刻開始用這個函式，
          而解除安裝也不會讓系統以為函式還賴著不走。
          這幾行應該緊跟在寫著函式名稱該行後面，如下：</para>

        <programlisting>
lib/libtvl80.so.1
@exec /sbin/ldconfig -m %D/lib
@unexec /sbin/ldconfig -R</programlisting>

        <para>絕對絕對，<emphasis>千萬不要</emphasis>在
          <filename>Makefile</filename> 或 <filename>pkg/PLIST</filename>
          裡加上一行沒有任何參數的 <literal>ldconfig</literal>。
          這樣會使得共享函式暫存區裡重設成只含 <filename>/usr/lib</filename>
          裡的內容，而且會像皇帝般地弄亂使用者的系統("救命，
          我裝完這個 port 後 xinit 就再也不動了")。
          任何這麼做的人都會被槍殺，用生鏽的刀大切 65,536 塊，
          被一群烏鴉把肝臟扯出剁碎，然後爛死在地獄深處，萬劫不復
          (不一定會照這順序來&hellip;)</para>
      </sect3>
    </sect2>

    <sect2>
      <title>ELF support</title>

      <para>自從 FreeBSD 在 3.0-RELEASE 後立刻改為 ELF binary format，
        我們要更換很多建立共享函式的 port 來支援 ELF。
        複雜的是 3.0 可以同時執行 ELF 和 a.out，
        而且我們希望非正式地支援 2.2，越久越好。
        下面這些指引如何更換只支援 a.out 的 port 以同時支援 a.out
        和 ELF。</para>

      <para>這份列表的某些部份只有在轉換過程中才適用，
        不過仍然留在這當作參考以免你遇到想要升級的老 port。</para>

      <sect3>
        <title>把 a.out 的函式移開</title>

        <para>任何 a.out 的函式都應該移開 <filename>/usr/local/lib</filename>
          到一個 <filename>aout</filename> 的子目錄。(如果不把它們移走，
          ELF ports 會很樂意把 a.out 的函式覆寫掉。) 在 3.0-CURRENT 的
          <filename>src/Makefile</filename> 裡的
          <maketarget>move-aout-libs</maketarget> (從
          <maketarget>aout-to-elf</maketarget> 呼叫)這個標的會幫你做這件事。
          它只會移動 a.ou 的函式，所以在同時有 ELF 和 a.out
          函式的標準目錄呼叫它很安全的。</para>
      </sect3>

      <sect3>
        <title>格式</title>

        <para>Ports tree 會依照系統的格式來建立 package。
          表示由 <command>`objformat`</command> 傳回的值決定在 2.2 是 a.out
          而在 3.0是 a.out 或 ELF。同樣地，一旦使用者將 a.out
          的函式移到一個子目錄下，將不支援建立 a.out
          的函式。(換句話說，如果你真的知道在做什麼的話仍然可以運作，
          不過得靠自己來。)</para>

        <note>
          <para>如果 port 只能在 a.out 環境執行，把
            <makevar>BROKEN_ELF</makevar> 設為一說明原因的字串。
            在 ELF 的系統上建立 port 時會把這類的跳過去。</para>
        </note>
      </sect3>

      <sect3>
        <title><makevar>PORTOBJFORMAT</makevar></title>

        <para><filename>bsd.port.mk</filename> 會把
          <makevar>PORTOBJFORMAT</makevar> 設為 <literal>aout</literal> 或
          <literal>elf</literal> 並將它輸出到環境變數
          <envar>CONFIGURE_ENV</envar>，<envar>SCRIPTS_ENV</envar> 和
          <envar>MAKE_ENV</envar>。(在 2.2-STABLE 裡永遠是
          <literal>aout</literal>)。它也會被以
          <literal>PORTOBJFORMAT=${PORTOBJFORMAT}</literal> 傳入
          <maketarget>PLIST_SUB</maketarget>。
          (看下面幾行 <literal>ldconfig</literal> 的說明。)</para>

        <para>這個變數設定使用 <filename>bsd.port.mk</filename> 裡這行：</para>

        <programlisting>
PORTOBJFORMAT!= test -x /usr/bin/objformat && /usr/bin/objformat || echo aout</programlisting>

        <para>Ports 的 make 程序應該用這個變數來決定該做什麼。
          然而，假如 port 的 <filename>configure</filename> script
          已經自動查出為 ELF 的系統，那就沒有必要參照
          <makevar>PORTOBJFORMAT</makevar>。</para>
      </sect3>

      <sect3>
        <title>建立共享函式</title>

        <para>接下來的在為 a.out 和 ELF 的系統處理共享函式的部份有很多不同。
          </para>

        <itemizedlist>
          <listitem>
            <para>共享函式的版本</para>

            <para>一個 ELF 的共享函式應該名為
              <filename>libfoo.so.<replaceable>M</replaceable></filename>，
              <replaceable>M</replaceable> 是個單一的版本編號，而 a.out
              的共享函式應該名為
              <filename>libfoo.so.<replaceable>M</replaceable>.<replaceable>N</replaceable></filename>，
              <replaceable>M</replaceable> 是主版本編號而
              <replaceable>N</replaceable> 是次版本編號。別把它們搞混了；
              <emphasis>千萬不要</emphasis>安裝一個叫做
              <filename>libfoo.so.<replaceable>N</replaceable>.<replaceable>M</replaceable></filename>
              的 ELF 共享函式，或是叫做
              <filename>libfoo.so.<replaceable>N</replaceable></filename>
              的 a.out 共享函式(或是符號連結)。</para>
          </listitem>

          <listitem>
            <para>連結器(linker)的命令列</para>

            <para>假設 <command>cc -shared</command> 比 <command>ld</command>
              用起來更直接，那唯一不同的地方就是在 ELF 系統的命令列要加上
              <option>-Wl,-<replaceable>soname,libfoo.so.M</replaceable></option>。
              </para>
            </listitem>
        </itemizedlist>

        <para>還需要安裝一個符號連結(symlink)從 <filename>libfoo.so</filename>
          到 <filename>libfoo.so.<replaceable>N</replaceable></filename>
          讓 ELF 的連結器快樂點。因為它也應該列在 <filename>PLIST</filename>
          裡，而且在 a.out 的情況下也不會造成傷害(有些 port
          甚至動態載入時仍需要個連結)，你只須要做個連結而不必管
          <makevar>PORTOBJFORMAT</makevar> 的設定。</para>
      </sect3>

      <sect3>
        <title><makevar>LIB_DEPENDS</makevar></title>

        <para><makevar>LIB_DEPENDS</makevar> 裡的次編號應該從所有 port 的
          <filename>Makefile</filename>s 移除，也要移除所有 regexp 的支援。
          (例如，<literal>foo\\.1\\.\\(33|40\\)</literal> 變成
          <literal>foo.2</literal>。)可以用 <command>grep -wF</command>
          把它們找出來。</para>
      </sect3>

      <sect3>
        <title><filename>PLIST</filename></title>

        <para>假如 a.out 的主編號是 0 則 <filename>PLIST</filename>
          應該包含短的(ELF)共享函式名稱，反之則為長的(a.out)共享函式名稱。
          <filename>bsd.port.mk</filename> 會在當
          <makevar>PORTOBJFORMAT</makevar> 等於 <literal>aout</literal>
          時自動於短的共享函式該行後加上 <literal>.0</literal>，而當
          <makevar>PORTOBJFORMAT</makevar> 等於 <literal>elf</literal>
          時刪去長的共享函式之次編號。</para>

        <para>萬一你真的必須在 ELF 的系統上安裝兩個版本的共享函式，
          或是要在 a.out 的系統安裝一個版本(例如安裝其它的作業系統的相容函式的
          port)，就設定變數 <makevar>NO_FILTER_SHLIBS</makevar>。
          這樣會關掉上一段裡所提到對 <filename>PLIST</filename> 編輯。</para>
      </sect3>

      <sect3>
        <title><literal>ldconfig</literal></title>

        <para><literal>ldconfig</literal> 那行在 Makefiles 裡應該讀取：</para>

        <programlisting>
${SETENV} OBJFORMAT=${PORTOBJFORMAT} ${LDCONFIG} -m ....</programlisting>

        <para>在 <filename>PLIST</filename> 裡應該讀取：</para>

        <programlisting>
@exec /usr/bin/env OBJFORMAT=%%PORTOBJFORMAT%% /sbin/ldconfig -m ...
@unexec /usr/bin/env OBJFORMAT=%%PORTOBJFORMAT%% /sbin/ldconfig -R</programlisting>

        <para>這是用來確定正確的 <command>ldconfig</command> 的呼叫是決定在
          package 的格式而不是系統的預設格式：</para>
      </sect3>
    </sect2>

    <sect2 id="porting-masterdir">
      <title><makevar>MASTERDIR</makevar></title>

      <para>如果 port 需要藉變數值的不同來建立稍微不同版本的 package
        (例如，resolution 或 paper size)，就替每個 package
        開個子目錄讓使用者更容易知道該做什麼，不過儘量讓各個 port 之間共用
        的檔案越多越好。如果你很巧妙地運用變數，
        那幾乎只須要在其中一個目錄放個簡短的 <filename>Makefile</filename>
        便可。在這些單一的 <filename>Makefiles</filename>，可以用
        <makevar>MASTERDIR</makevar> 來說明其它的檔案在哪個目錄。
        同樣地，使用一個變數做為
        <link linkend="porting-pkgname"><makevar>PKGNAME</makevar></link>
        的一部份，讓每個 package 擁有不同的名稱。</para>

      <para>一個例子是最佳的說明。這是
        <filename>japanese/xdvi300/Makefile</filename> 的一部份；</para>

      <programlisting>
PKGNAME=       ja-xdvi${RESOLUTION}-17
 :
# default
RESOLUTION?=   300
.if ${RESOLUTION} != 118 && ${RESOLUTION} != 240 && \
       ${RESOLUTION} != 300 && ${RESOLUTION} != 400
       @${ECHO} "Error: invalid value for RESOLUTION: \"${RESOLUTION}\""
       @${ECHO} "Possible values are: 118, 240, 300 (default) and 400."
       @${FALSE}
.endif</programlisting>

      <para><filename>japanese/xdvi300</filename> 也有所有正式的 patch，
        package 檔案....等等。如果在此鍵入 <command>make</command>，
        它會取用預設值做為 resolution 的值(300)並照一般情形建立 port。</para>

      <para>對其它 resolution 來說，這是<emphasis>完整的</emphasis>
        <filename>xdvi118/Makefile</filename>：</para>

      <programlisting>
RESOLUTION=     118
MASTERDIR=      ${.CURDIR}/../xdvi300

.include ${MASTERDIR}/Makefile</programlisting>

      <para>(<filename>xdvi240/Makefile</filename> 和
        <filename>xdvi400/Makefile</filename> 差不多)。
        <makevar>MASTERDIR</makevar> 的定義告訴
        <filename>bsd.port.mk</filename> 說 <makevar>PATCHDIR</makevar> 和
        <makevar>PKGDIR</makevar> 這類正式的子目錄的設定在
        <filename>xdvi300</filename> 下面。<literal>RESOLUTION=118</literal>
        這行會蓋掉 <filename>xdvi300/Makefile</filename> 裡的
        <literal>RESOLUTION=300</literal>，而 port
        會以 resolution 為 118 來建立。</para>
    </sect2>

    <sect2>
      <title>共享函式的版本</title>

      <para>首先，請先讀讀<link linkend="policies-shlib">共享函式版本的政策</link>
        以了解一般如何決定共享函式的版本。不要盲目地以為軟體作者知道他們在做什麼；
        很多都不知道。謹慎地考慮這些細節是很重要的，
        因為我們試著讓一堆可能不相容的軟體一起存在，這是相當獨特的情況。
        在以前粗心的 port 曾經在共享函式的認定上造成很大的困擾。
        (有沒有想過為什麼 <filename>jpeg-6b</filename> 的共享函式版本是
        9.0？)。不信的話就到 &a.ports; 問問。大部份的時候，
        你的工作最後就是決定共享函式的版本和做出適當的 patch 來做這件事。</para>

      <para>然而，如果有個 port 跟 port tree 裡同一軟體的版本不同的話，
        那就更複雜了。簡單的說，FreeBSD
        的實行並不允許使用者指定連結器連結哪一版本的共享函式
        (連結器永遠都挑選編號最高的版本)。這表示假如系統裡有
        <filename>libfoo.so.3.2</filename> 和 <filename>libfoo.so.4.0</filename>，
        就沒有辦法叫連結器連結個別的應用程式到
        <filename>libfoo.so.3.2</filename>。It is essentially completely
        overshadowed in terms of compilation-time linkage.在這情形下，
        唯一的解決辦法就是更改共享函式<emphasis>基礎</emphasis>部份的名稱。
        例如，把 <filename>libfoo.so.4.0</filename> 改成
        <filename>libfoo4.so.1.0</filename> 這樣 3.2 和 4.0
        的版本便都可以從其它 port 連結。</para>
    </sect2>

    <sect2 id="porting-manpages">
      <title>Manpages</title>

      <para><makevar>MAN[1-9LN]</makevar> 這些變數會自動把任何 manpage 加進
        <filename>pkg/PLIST</filename> (這表示絕<emphasis>不要</emphasis>
        把 manpage 列在 <filename>PLIST</filename> 裡 &mdash; <link 
          linkend="porting-plist">generating PLIST</link> 有更多料)。
        在安裝的階段是否會壓縮 manpage 決定於 <filename>/etc/make.conf</filename>
        裡是否有設定 <makevar>NOMANCOMPRESS</makevar>。</para>

      <para>如果要用符號連結(symlink)或實體連結(hardlink)為 manpage
        安裝多個名稱，則應該用 <makevar>MLINKS</makevar> 這個變數來確認。
        Port 所安裝的連結會被 <filename>bsd.port.mk</filename>
        毀掉或重新創造以確定它指向正確的檔案。任何列在 MLINKS
        的 manpage 絕不可列在 <filename>PLIST</filename> 裡。</para>

      <para>要指定 manpage 是否在安裝時壓縮可用變數
        <makevar>MANCOMPRESSED</makevar>。這個變數有三個值可用，
        <literal>yes</literal>，<literal>no</literal> 和
        <literal>maybe</literal>。<literal>yes</literal> 表示 manpages 
        已經以壓縮過的形式安裝，<literal>no</literal> 表示沒有壓縮，
        而 <literal>maybe</literal> 表示早已遵守
        <makevar>NOMANCOMPRESS</makevar> 的值，所以
        <filename>bsd.port.mk</filename> 並不需要做什麼特別的事了。</para>

      <para>假如設定了 <makevar>USE_IMAKE</makevar> 而且沒有設定
        <makevar>NO_INSTALL_MANPAGES</makevar>，則
        <makevar>MANCOMPRESSED</makevar> 會自動設為 <literal>yes</literal>，
        反之則設為 <literal>no</literal>。沒有必要明確地定義它，
        除非預設值不適合你的 port。</para>

      <para>如果你的 port 的主要樹狀結構位於 <makevar>PREFIX</makevar>
        以外，可以用 <makevar>MANPREFIX</makevar> 來設定。
        同樣地，如果只有特定章節的 manpages 在不標準的地方，
        例如一些 Perl 模組(module)的 port，可以利用
        <makevar>MAN<replaceable>sect</replaceable>PREFIX</makevar>
        (<replaceable>sect</replaceable> 是 <literal>1-9</literal>，
        <literal>L</literal> 或 <literal>N</literal> 其中之一)
        來設定個別的主要路徑。</para>

      <para>如果 manpages 裝在指定語言的子目錄，
        把 <makevar>MANLANG</makevar> 設為該語言的名稱。
        這個變數的預設值是 <literal>""</literal> (也就是只有英文)。</para>

      <para>這個例子把上面說的都放一起了。</para>

      <programlisting>
MAN1=          foo.1
MAN3=          bar.3
MAN4=          baz.4
MLINKS=        foo.1 alt-name.8
MANLANG=       "" ja
MAN3PREFIX=    ${PREFIX}/share/foobar
MANCOMPRESSED= yes</programlisting>

      <para>這表示這個 port 裝了六個檔案；</para>

          <programlisting>
${PREFIX}/man/man1/foo.1.gz
${PREFIX}/man/ja/man1/foo.1.gz
${PREFIX}/share/foobar/man/man3/bar.3.gz
${PREFIX}/share/foobar/man/ja/man3/bar.3.gz
${PREFIX}/man/man4/baz.4.gz
${PREFIX}/man/ja/man4/baz.4.gz</programlisting>

      <para>附加的 <filename>${PREFIX}/man/man8/alt-name.8.gz</filename>
        可能會也可能不會被 port 安裝。無論如何，
        foo(1) manpage 和 alt-name(8) manpage 會用一個符號連結(symlink)接起來。
        </para>

    </sect2>

    <sect2 id="porting-motif">
      <title>需要 Motif 的 ports</title>

      <para>有很多程式需要 Motif 的函式(可以從一些商業性的廠商取得，
        雖然有報導指出很多應用程式也可以用免錢的彷製軟體
        <filename>x11-toolkits/lesstif</filename> 來執行)來編譯。
        因為這是個很普及的 toolkit 而且它的授權通常允許使用者重覆散佈靜態連結的
        binary，我們為處理需要 Motif 的 port 做了些準備，就某觀點而言，
        這樣不論是動態(為了那些從 port 編譯的人)或是靜態(為了散佈 package 的人)
        連結的 binary 都可以容易地編譯。</para>

      <sect3>
        <title><makevar>REQUIRES_MOTIF</makevar></title>

        <para>如果 port 需要 Motif，在 Makefile
          裡定義這個變數。這樣可以防止沒有 Motif 的人試圖去編譯它。</para>
      </sect3>

      <sect3>
        <title><makevar>MOTIFLIB</makevar></title>

        <para>這個變數在 <filename>bsd.port.mk</filename> 設定，
          用來適當的參考 Motif 的函式。不論 Motif 的函式是在
          <filename>Makefile</filename> 或 <filename>Imakefile</filename>
          裡被參考，請 patch 程式碼以使用這個變數。</para>

        <para>有兩種一般的情況：</para>

        <itemizedlist>
          <listitem>
            <para>如果 port 在它的 <filename>Makefile</filename> 或
              <filename>Imakefile</filename> 以 <literal>-lXm</literal>
              來參考 Motif 的函式，只要把它換成
              <literal>&dollar;{MOTIFLIB}</literal>。</para>
          </listitem>

          <listitem>
            <para>如果 port 在它的 <filename>Imakefile</filename> 用
              <literal>XmClientLibs</literal>，把它改成
              <literal>&dollar;{MOTIFLIB} &dollar;{XTOOLLIB}
                &dollar;{XLIB}</literal>。</para>
          </listitem>

        </itemizedlist>

        <para>注意 <makevar>MOTIFLIB</makevar> (通常)展開成
          <literal>-L/usr/X11R6/lib -lXm</literal> 或
          <literal>/usr/X11R6/lib/libXm.a</literal>，所以沒有必要在前面加上
          <literal>-L</literal> 或 <literal>-l</literal>。</para>
      </sect3>
    </sect2>

    <sect2>
      <title>X11 的字型</title>

      <para>如果 port 會為 X Window system 安裝字型，把字型放到
        <filename><makevar>X11BASE</makevar>/lib/X11/fonts/local</filename> 裡。
        這個目錄是 XFree86 release 3.3.3 新有的。如果不存在的話請開一個，
        並印出一個訊息催促使用者升級他們的 XFree86 到 3.3.3 或更新的，
        或者至少把這個目錄加進 <filename>/etc/XF86Config</filename>
        裡的字型路徑。</para>
    </sect2>

    <sect2>
      <title>Info 檔</title>

      <para>新版的 texinfo (包括在 2.2.2-RELEASE 和之後的)
        包含一個實用的程式叫做 <command>install-info</command>，
        用來增加或刪除記錄到 <filename>dir</filename> 裡。如果 port 安裝任何的
        info 文件，請跟著這些指引，這樣 port/package 才會正確地更新使用者的
        <filename><makevar>PREFIX</makevar>/info/dir</filename> 檔案。
        (抱歉這一章這麼長，不過把所有的 info 檔案編在一起是必要的。
        如果做的正確將會產生一個<emphasis>漂亮的</emphasis>列表，
        所以請跟我一起忍吧！</para>

      <para>首先，這是你(身為一個 porter)得知道的</para>

      <screen>&prompt.user; <userinput>install-info --help</userinput>
install-info [OPTION]... [INFO-FILE [DIR-FILE]]
  Install INFO-FILE in the Info directory file DIR-FILE.

Options:
--delete          Delete existing entries in INFO-FILE;
                    don't insert any new entries.
 :
--entry=TEXT      Insert TEXT as an Info directory entry.
 :
--section=SEC     Put this file's entries in section SEC of the directory. :</screen>

      <note>
        <para>這個程是並不會真的<emphasis>安裝</emphasis> info 檔案；
          它只是在 <filename>dir</filename> 檔裡插入或刪除記錄。</para>
      </note>

      <para>這裡有七個步驟的程序用來更換 port 來使用
        <command>install-info</command>。我會用
        <filename>editors/emacs</filename> 當例子。</para>

      <procedure>
        <step>
          <para>檢視 texinfo 程式碼並做個 patch 來把
            <literal>@dircategory</literal> 和 <literal>@direntry</literal>
            加進沒有這兩個敘述的檔案。這是我的 patch 的一部份：</para>

          <programlisting>
--- ./man/vip.texi.org  Fri Jun 16 15:31:11 1995
+++ ./man/vip.texi      Tue May 20 01:28:33 1997
@@ -2,6 +2,10 @@
             
 @setfilename ../info/vip
 @settitle VIP
+@dircategory The Emacs editor and associated tools
+@direntry
+* VIP: (vip).          A VI-emulation for Emacs.
+@end direntry
             
 @iftex
 @finalout
 :</programlisting>

          <para>這格式應該是一看就懂的。很多作者把 <filename>dir</filename>
            檔留在 source tree 裡，該檔包含所有所需的記錄，
            所以在要寫一個自己的檔前先留意一下。同樣地，確定有查看相關的 ports
            並讓章節的名稱和記錄一致(我們建議所有記錄的正文從第四個 tab
            停止的地方開始)。</para>

          <note>
            <para>要注意每個檔案只能有一筆 info 記錄因為
              <command>install-info --delete</command>
              的一個錯誤導致如果 <email>@direntry</email>
              的部份有多個記錄也只會砍掉第一個。</para>
          </note>

          <para>可以把 <literal>dir</literal> 的記錄給
            <command>install-info</command> 當參數用
            (<option>--section</option> 和 <option>--entry</option>)
            以取代 patch texinfo 原始碼。我不認為這對 port 來說是好方法，
            因為這樣必須把同樣的東西複製到<emphasis>三個</emphasis>地方
            (<filename>Makefile</filename> 和 <filename>PLIST</filename> 的
            <literal>@exec</literal>/<literal>@unexec</literal>；
            看下面)。可是如果有日文的(或是其它雙位元編碼的) info 檔，
            這樣 <command>install-info</command> 必須用額外的參數，
            因為 <command>makeinfo</command> 不能處理那些 texinfo 程式碼。
            (拿 <filename>japanese/skk</filename> 的 <filename>Makefile</filename>
            和 <filename>PLIST</filename> 當例子看看怎麼做)。</para>
        </step>

        <step>
          <para>回到 port 的目錄執行 <command>make clean; make</command>
            並確認 info 檔已經從 texinfo 程式碼重新產生。
            既然 texinfo 程式碼比 info 檔還新，當鍵入 <command>make</command>
            時就應該被重新建立；不過很多 <filename>Makefile</filename>s
            並沒有為 info 檔包含正確的 dependency。在 <command>emacs</command>
            的情況，便必須 patch 主要的<filename>Makefile.in</filename>
            這樣它才會往下到 <filename>man</filename> 的子目錄重新建立 info。
            </para> 

          <programlisting>
--- ./Makefile.in.org   Mon Aug 19 21:12:19 1996
+++ ./Makefile.in       Tue Apr 15 00:15:28 1997
@@ -184,7 +184,7 @@
 # Subdirectories to make recursively.  `lisp' is not included
 # because the compiled lisp files are part of the distribution
 # and you cannot remake them without installing Emacs first.
-SUBDIR = lib-src src
+SUBDIR = lib-src src man
 
 # The makefiles of the directories in $SUBDIR.
 SUBDIR_MAKEFILES = lib-src/Makefile man/Makefile src/Makefile oldXMenu/Makefile
 lwlib/Makefile
--- ./man/Makefile.in.org       Thu Jun 27 15:27:19 1996
+++ ./man/Makefile.in   Tue Apr 15 00:29:52 1997
@@ -66,6 +66,7 @@
 ${srcdir}/gnu1.texi \
 ${srcdir}/glossary.texi
             
+all: info
 info: $(INFO_TARGETS)
             
 dvi: $(DVI_TARGETS)</programlisting>

          <para>第二塊(hunk)是必要的因為子目錄 <filename>man</filename>
            預設的標的叫做 <maketarget>info</maketarget>，而主要的
            <filename>Makefile</filename> 會呼叫 <maketarget>all</maketarget>。
            我也刪除了 <filename>info</filename> 檔的安裝因為
            <filename>/usr/share/info</filename> 裡已經有一個同名的檔案
            (那個 patch 沒有在這秀出來)。</para>
        </step>

        <step>
          <para>如果 <filename>Makefile</filename> 裡有個地方會安裝
            <filename>dir</filename> 檔，砍了它。你的 port 可能不會麼這做。
            同樣地，刪去任何以別的方式弄髒 <filename>dir</filename>
            檔的命令。</para>

          <programlisting>
--- ./Makefile.in.org   Mon Aug 19 21:12:19 1996
+++ ./Makefile.in       Mon Apr 14 23:38:07 1997
@@ -368,14 +368,8 @@
        if [ `(cd ${srcdir}/info && /bin/pwd)` != `(cd ${infodir} && /bin/pwd)` ]; \
        then \
          (cd ${infodir};  \
-          if [ -f dir ]; then \
-            if [ ! -f dir.old ]; then mv -f dir dir.old; \
-            else mv -f dir dir.bak; fi; \
-          fi; \
           cd ${srcdir}/info ; \
-          (cd $${thisdir}; ${INSTALL_DATA} ${srcdir}/info/dir ${infodir}/dir); 
\
-          (cd $${thisdir}; chmod a+r ${infodir}/dir); \
           for f in ccmode* cl* dired-x* ediff* emacs* forms* gnus* info* message* mh-e* sc* vip*; do \
             (cd $${thisdir}; \
              ${INSTALL_DATA} ${srcdir}/info/$$f ${infodir}/$$f; \
              chmod a+r ${infodir}/$$f); \</programlisting>
        </step>

        <step>
          <para>(這個步驟只有在修改一個現存的 port 時才需要。)
            看一下 <filename>pkg/PLIST</filename> 並刪去任何試著修改
            <filename>info/dir</filename> 的部份。
            可能在 <filename>pkg/INSTALL</filename> 或其它檔案裡，
            所以大規模地搜索吧。</para>

          <programlisting>
Index: pkg/PLIST
===================================================================
RCS file: /usr/cvs/ports/editors/emacs/pkg/PLIST,v
retrieving revision 1.15
diff -u -r1.15 PLIST
--- PLIST       1997/03/04 08:04:00     1.15
+++ PLIST       1997/04/15 06:32:12
@@ -15,9 +15,6 @@
 man/man1/emacs.1.gz
 man/man1/etags.1.gz
 man/man1/ctags.1.gz
-@unexec cp %D/info/dir %D/info/dir.bak
-info/dir
-@unexec cp %D/info/dir.bak %D/info/dir
 info/cl
 info/cl-1
 info/cl-2</programlisting>
        </step>

        <step>
          <para>在 <filename>Makefile</filename> 加一個
            <maketarget>post-install</maketarget> 的標的來呼叫
            伴隨著要安裝的 info 檔的 <maketarget>install-info</maketarget>。
            (不需要再自己建一個 <filename>dir</filename> 檔了；當它不存在時
            <command>install-info</command> 會自動創造一個。)</para>

          <programlisting>
Index: Makefile
===================================================================
RCS file: /usr/cvs/ports/editors/emacs/Makefile,v
retrieving revision 1.26
diff -u -r1.26 Makefile
--- Makefile    1996/11/19 13:14:40     1.26
+++ Makefile    1997/05/20 10:25:09     1.28
@@ -20,5 +20,8 @@
 post-install:
 .for file in emacs-19.34 emacsclient etags ctags b2m
        strip ${PREFIX}/bin/${file}
 .endfor
+.for info in emacs vip viper forms gnus mh-e cl sc dired-x ediff ccmode
+       install-info ${PREFIX}/info/${info} ${PREFIX}/info/dir
+.endfor
             
 .include &lt;bsd.port.mk&gt;</programlisting>
        </step>

        <step>
          <para>編輯 <filename>PLIST</filename> 並加上等效的
            <literal>@exec</literal> 敘述還有因應 <command>pkg_delete</command>
            的 <literal>@unexec</literal>。</para>

          <programlisting>
Index: pkg/PLIST
===================================================================
RCS file: /usr/cvs/ports/editors/emacs/pkg/PLIST,v
retrieving revision 1.15
diff -u -r1.15 PLIST
--- PLIST       1997/03/04 08:04:00     1.15
+++ PLIST       1997/05/20 10:25:12     1.17
@@ -16,7 +14,14 @@
 man/man1/etags.1.gz
 man/man1/ctags.1.gz
+@unexec install-info --delete %D/info/emacs %D/info/dir
 :
+@unexec install-info --delete %D/info/ccmode %D/info/dir
 info/cl
 info/cl-1
@@ -87,6 +94,18 @@
 info/viper-3
 info/viper-4
+@exec install-info %D/info/emacs %D/info/dir
 :
+@exec install-info %D/info/ccmode %D/info/dir
 libexec/emacs/19.34/i386--freebsd/cvtmail
 libexec/emacs/19.34/i386--freebsd/digest-doc</programlisting>

          <note>
            <para><literal>@unexec install-info --delete</literal> 這個命令
              必須列在 info 檔之前，這樣才可以讀取這個檔。同樣地，
              <literal>@exec install-info</literal> 這個指令要在 info 檔
              和創造 <filename>dir</filename> 檔的命令 <literal>@exec</literal>
              之後。</para>
          </note>
        </step>

        <step>
          <para><link linkend="porting-testing">測試</link>並誇讚你的成果吧。
            <!-- smiley --><emphasis>:-)</emphasis>。
            在每個步驟開始之前和之後檢查 <filename>dir</filename> 檔。</para>
        </step>
      </procedure>
    </sect2>

    <sect2>
      <title>子目錄 <filename>pkg/</filename></title>

      <para>這有一些有關 <filename>pkg/</filename> 而我們未曾提及的小技巧，
        有時後它們也會派上用場。</para>

      <sect3 id="porting-message">
        <title><filename>MESSAGE</filename></title>

        <para>如果要對安裝的人顯示訊息的話，可以把訊息放在
          <filename>pkg/MESSAGE</filename> 裡。這個功能在當
          <command>pkg_add</command> 之後要顯示額外的安裝步驟，
          或是要顯示授權資訊時往往相當有用。</para>

        <note>
          <para><filename>pkg/MESSAGE</filename> 這個檔不需要加進
            <filename>pkg/PLIST</filename> 裡。同樣地，如果使用者是用 port
            而非 package，那它就不會自動顯示出來，所以你應該自己在
            <maketarget>post-install</maketarget> 的標的裡把它顯示出來。
            </para>
        </note>
      </sect3>

      <sect3>
        <title><filename>INSTALL</filename></title>

        <para>如果 port 在用 <command>pkg_add</command> 安裝 binary package
          時需要執行命令，可以藉由 <filename>pkg/INSTALL</filename> 這個
          script 來達成。這個 script 會自動加進 package 裡，且會藉由
          <command>pkg_add</command> 執行兩次。第一次是 <literal>INSTALL
            &dollar;{PKGNAME} PRE-INSTALL</literal> 而第二次是
          <literal>INSTALL &dollar;{PKGNAME} POST-INSTALL</literal>。
          <literal>&dollar;2</literal> 可用以確定 script 正進入何種模式。
          <envar>PKG_PREFIX</envar> 這個環境變數會設定為 package 的安裝目錄。
          查看 &man.pkg.add.1; 以獲得更多訊息。</para>

        <note>
          <para>如果用 <command>make install</command> 安裝 port，則此 script
            不會自動執行。如果你必須依賴它的執行，則必須在 port 的
            <filename>Makefile</filename> 裡明確地呼叫它。</para>
        </note>
      </sect3>

      <sect3>
        <title><filename>REQ</filename></title>

        <para>如果 port 需要決定它是否應該安裝，則可建一個
          <filename>pkg/REQ</filename> &ldquo;必備條件(requirements)&rdquo;
          的 script。在安裝/反安裝時它會被自動採用以決定
          安裝/反安裝程序是否繼續進行。</para>
      </sect3>

      <sect3 id="porting-plist">
        <title>根據 make 的變數改變 <filename>PLIST</filename></title>

        <para>有些 port，尤其是 p5- 的 port，必須取決於 configure
          時用的選項(或是在 p5- ports 時為 perl 的版本)來改變
          <filename>PLIST</filename>。要使這更容易一點，在
          <filename>PLIST</filename> 裡的 <literal>%%OSREL%%</literal>，
          <literal>%%PERL_VER%%</literal> 和 <literal>%%PERL_VERSION%%</literal>
          的任何 instance 都將被適當地替代。<literal>%%OSREL%%</literal>
          的值是作業系統的修訂版號碼(如 <literal>2.2.7</literal>)。
          <literal>%%PERL_VERSION%%</literal> 是 perl 完整的版本編號(如
          <literal>5.00502</literal>) 而 <literal>%%PERL_VER%%</literal>
          則是 perl 版本編號減去 patchlevel (如 <literal>5.005</literal>)。
          </para>

        <para>如果必須做其它的替代，可以用成對的
          <literal><replaceable>VAR</replaceable>=<replaceable>VALUE</replaceable></literal>
          的列表來設定變數 <makevar>PLIST_SUB</makevar>，而
          <literal>%%<replaceable>VAR</replaceable>%%</literal> 的 instance
          將會被 <filename>PLIST</filename> 裡的 <replaceable>VALUE</replaceable>
          所取代。</para>

        <para>舉個例，假如有個 port 安裝了很多檔案在一個指定版本的子目錄，
          可以把一個類似

          <programlisting>
OCTAVE_VERSION= 2.0.13
PLIST_SUB=      OCTAVE_VERSION=${OCTAVE_VERSION}</programlisting>

          的東西放進 <filename>Makefile</filename> 並在所有
          <filename>PLIST</filename> 裡出現版本的位置使用
          <literal>%%OCTAVE_VERSION%%</literal>。照這方法，當你升級 port
          時就不必更改 <filename>PLIST</filename> 裡那數(或者在一些情形下，
          數百)行的東西。</para>

        <para>這種替代(以及任何 <link
            linkend="porting-manpages">man pages</link>)
          的增加)會藉由讀取 <makevar>PLIST</makevar> 和寫入
          <makevar>TMPPLIST</makevar>(預設：
          <filename><makevar>WRKDIR</makevar>/.PLIST.mktmp</filename>)在
          <maketarget>do-install</maketarget> 和
          <maketarget>post-install</maketarget> 的標的之間完成
          因此假如你匆忙地建立 <makevar>PLIST</makevar>，在
          <maketarget>do-install</maketarget> 裡或之前這樣做。同樣地，
          如果 port 必須編輯結果的檔案，在
          <maketarget>post-install</maketarget> 裡對名為
          <makevar>TMPPLIST</makevar> 的檔案這麼做。</para>
      </sect3>

      <sect3>
        <title id="porting-pkgsubdir">改變子目錄 <filename>pkg</filename>
          裡的檔案名稱</title>

        <para>所有在子目錄 <filename>pkg</filename> 裡的檔名都是用變數定義的，
          所以假如需要可以在 <filename>Makefile</filename> 裡改變它們。
          當要在數個 port 間分享同一個子目錄 <filename>pkg</filename>，
          或者必須寫入上面所述檔案中的某個檔案(看看
          <link linkend="porting-wrkdir">在 <makevar>WRKDIR</makevar>
          以外的地方寫入</link>可知為何直接寫入子目錄 <filename>pkg</filename>
          是個爛方法)時，這方法特別地有用。</para>

        <para>這裡有份變數名稱及其預設值的列表。</para>

        <informaltable frame="none">
          <tgroup cols="2">
            <thead>
              <row>
                <entry>變數</entry>
                <entry>預設值</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><makevar>COMMENT</makevar></entry>
                <entry><literal>${PKGDIR}/DESCR</literal></entry>
              </row>

              <row>
                <entry><makevar>DESCR</makevar></entry>
                <entry><literal>${PKGDIR}/DESCR</literal></entry>
              </row>

              <row>
                <entry><makevar>PLIST</makevar></entry>
                <entry><literal>${PKGDIR}/PLIST</literal></entry>
              </row>

              <row>
                <entry><makevar>PKGINSTALL</makevar></entry>
                <entry><literal>${PKGDIR}/PKGINSTALL</literal></entry>
              </row>

              <row>
                <entry><makevar>PKGDEINSTALL</makevar></entry>
                <entry><literal>${PKGDIR}/PKGDEINSTALL</literal></entry>
              </row>

              <row>
                <entry><makevar>PKGREQ</makevar></entry>
                <entry><literal>${PKGDIR}/REQ</literal></entry>
              </row>

              <row>
                <entry><makevar>PKGMESSAGE</makevar></entry>
                <entry><literal>${PKGDIR}/MESSAGE</literal></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>請改變這些變數而不要亂弄 <makevar>PKG_ARGS</makevar>。
          如果改變了 <makevar>PKG_ARGS</makevar>，則從 port
          安裝時那些檔案便不會被正確地安裝到
          <filename>/var/db/pkg</filename>。</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Licensing Problems</title>

      <para>有些軟體 package 有許可的限制或可造成違法(PKP 在 public key crypto
        的專利權，ITAR (crypto 軟體的輸出)這兩個恰屬於這種)。
        對這種軟體我們的作法差異很大，端賴於個別的許可的確實說法。</para>

      <note>
        <para>身為一個 porter，有責任要了解軟體的許可條件，並確保
          FreeBSD project 不會因為重新散佈程式碼或編譯過的 binary
          而為違反許可負責任，不論是經由 ftp 或光碟。如果不肯定的話請與
          &a.ports; 聯繫。</para>
      </note>

      <para>有兩個變數可以設在 Makefile 裡以處理經常發生的情況：</para>

      <orderedlist>
        <listitem>
          <para>如果 port 有&ldquo;不可售以獲利&rdquo;這種形式的許可，設定變數
            <makevar>NO_CDROM</makevar> 為一敘述原因的字串。我們會確定這類的
            port 不會在 release 時進入光碟裡。而 distfile 和 package
            仍可經由取得。</para>
        </listitem>

        <listitem>
          <para>如果 resulting package 必須在各個站獨立建立，或者
            resulting binary package 因為許可不得散佈；設定變數
            <makevar>NO_PACKAGE</makevar> 為一敘述原因的字串。我們會確定這類的
            package 不會出現在 ftp 站上，也不會在 release 時進入光碟裡。
            而 distfile 仍會包括在那兩者裡。</para>
        </listitem>

        <listitem>
          <para>假如 port 有法定的限制可使用的人(如 crypto
            此類)或者有 &ldquo;非營利用途&rdquo;的許可，設定變數
            <makevar>RESTRICTED</makevar> 為敘述原因的字串。對這類的 port，
            distfiles/packages 即使從我們的 ftp 站也無法取得。</para>
        </listitem>
      </orderedlist>

      <note>
        <para>第一版跟第二版的 GNU 大眾公用版權(GPL)對 port
          應該都不是個問題。</para>
      </note>

      <note>
        <para>如果你是個 committer，確定你也更新了
          <filename>ports/LEGAL</filename>。</para>
      </note>
    </sect2>

    <sect2 id="port-upgrading">
      <title>升級</title>

      <para>當你的 port 比來自起源作者的最新版還老舊時，先確保你有最新的 port。
        可以從 ftp mirror 站的目錄 <filename>ports/ports-current</filename>
        取得。也可以用 CVSup 使整個 ports collection 保持為新的，如同
        <xref linkend="cvsup-config"> 裡所描述的。</para>

      <para>下一步是寄信給 maintainer，如果 port 的
        <filename>Makefile</filename> 有列出。那個人可能已經在著手升級，
        或者有現在不升級的原因(例如因為新版本的穩定性問題)。</para>

      <para>如果 maintainer 要你進行升級或是沒有任何人開始著手，
        請做好升級並把新的和舊的 port 目錄的 recursive diff (unified 或
        context diff 也好，不過 port committer 似乎比較喜歡 unified diff)
        給我們(比如，如果修改的 port 目錄是 <filename>superedit</filename> 
        而原本在 port tree 裡的是 <filename>superedit.bak</filename>，
        接著就把 <command>diff -ruN superedit.bak superedit</command>
        的結果寄給我們)。請檢查輸出訊息確定所有的改變都有道理。把 diff
        寄給我們最好的方法就是把它包括進 &man.send-pr.1; (分類為
        <literal>ports</literal>)。請在訊息裡提及增加或刪除的檔案，
        因為當 commit 時它們必須被明確地記入 CVS。如果 diff 大於 20KB，
        請把它壓縮並 uuencode：不然就只要把它包含進來如同包含進 PR。</para>

      <note>
        <para>再說一次，請用 &man.diff.1; 來寄出現存的 port 的更新而不要用
          &man.shar.1;</para> 
      </note>
    </sect2>

    <sect2>
      <title><anchor id="porting-dads">Do's and Dont's</title>

      <para>這裡有份當在 porting 過程中應該與不應該下的命令的列表。
        你應該比對這份列表來檢查自己的 port，不過也可以檢查 PR
        資料庫裡其他人提出的 port。以 &lt;link linkend="contrib-general"&gt;Bug
        Reports and General Commentary&lt;/link&gt; 所描述的來提出所檢查的 port
        的註解。檢查 PR 資料庫裡的 port 不僅讓我們能更快地 commit 它們，
        而且也證明了你知道你在幹什麼。</para>

      <sect3>
        <title>Strip Binaries</title>

        <para>Do strip binaries.  如果原本的程式碼已經 strips the binaries，
          那很好；否則就應該自己加一個 <literal>post-install</literal> 的規則
          來做這件事。這裡有個例子：</para>

        <programlisting>
post-install:
        strip ${PREFIX}/bin/xdl</programlisting>

        <para>用 &man.file.1; 這個命令在一個可安裝的執行檔上來檢查這個 binary
          是否有被 strip。如果它沒有說 <literal>not stripped</literal>，
          就表示這個檔已經被 strip。</para> 
      </sect3>

      <sect3>
        <title>INSTALL_* macros</title>

        <para>在 <maketarget>*-install</maketarget> 的標的裡使用
          <filename>bsd.port.mk</filename>
          裡提供的巨集指令來確保檔案有正確的模式和擁有權。
          這些指令是：</para>

        <itemizedlist>
          <listitem>
            <para><makevar>INSTALL_PROGRAM</makevar> 這個指令是安裝 binary
              的可執行檔。</para>
          </listitem>

          <listitem>
            <para><makevar>INSTALL_SCRIPT</makevar> 這個指令是安裝可執行的
              script。</para>
          </listitem>

          <listitem>
            <para><makevar>INSTALL_DATA</makevar> 這個指令是安裝可分享的資料。
              </para>
          </listitem>

          <listitem>
            <para><makevar>INSTALL_MAN</makevar> 這個指令是安裝 manpage 和其它
              文件(它不會壓縮任何東西)。</para>
          </listitem>
        </itemizedlist>

        <para>這些是有所有適當的旗標的基本 <command>install</command> 指令。
          看下面的例子以知如何使用它們。</para>
      </sect3>

      <sect3 id="porting-wrkdir">
        <title><makevar>WRKDIR</makevar></title>

        <para>不要在 <makevar>WRKDIR</makevar> 以外寫入任何東西。
          <makevar>WRKDIR</makevar> 是建立 port 時唯一保證可寫入的地方
          (<link linkend="ports-cd">從光碟編譯 port</link> 有從唯讀的 tree
          編譯 port 的例子)。如果必須修改任何 <makevar>PKGDIR</makevar>
          裡的檔案，藉由<link linkend="porting-pkgsubdir">重新定義一個變數來做</link>，
          而不是直接寫入。</para>
      </sect3>

      <sect3 id="porting-wrkdirprefix">
        <title><makevar>WRKDIRPREFIX</makevar></title>

        <para>確保你的 port 會尊敬 <makevar>WRKDIRPREFIX</makevar>。
          大部份的 port 不用擔心這個。特別是假如你參考另一個 port 的
          <makevar>WRKDIR</makevar>，正確的位置應為
          <filename><makevar>WRKDIRPREFIX</makevar><makevar>PORTSDIR</makevar>/<replaceable>subdir</replaceable>/<replaceable>name</replaceable>/work</filename> 而不是 <filename><makevar>PORTSDIR</makevar>/<replaceable>subdir</replaceable>/<replaceable>name</replaceable>/work</filename> 或 <filename><makevar>.CURDIR</makevar>/../../<replaceable>subdir</replaceable>/<replaceable>name</replaceable>/work</filename> 或者一些這類的。</para>

        <para>同樣地，如果自己定義 <makevar>WRKDIR</makevar>， 
          確定你有在前面加上
          <literal>&dollar;{WRKDIRPREFIX}&dollar;{.CURDIR}</literal>。</para>
      </sect3>

      <sect3 id="porting-versions">
        <title>區別作業系統和 OS 版本</title>

        <para>你可能會遇到必需修改或是有條件的編譯的程式碼，這要看它是以何種版本
          UNIX 為基礎來執行。如果為了有條件的編譯必須對程式碼做這類的更改，
          確定你有盡量把它改的一般化點以便我們可以把 port 往回移植到 FreeBSD 1.x
          的系統而且可以移植到其它的 BSD 系統，如源自 CSRG 的 4.4BSD、BSD/386、
          386BSD、NetBSD 和 OpenBSD。</para>

        <para>分辨 4.3BSD/Reno (1990) 和較新版的 BSD 的程式碼較好的方法是用
          <filename>&lt;sys/param.h&gt;</filename> 裡定義的
          <literal>BSD</literal> 巨集指令。希望那個檔已經被包括進去了；
          假如沒有，把這段程式碼：</para>

        <programlisting>
#if (defined(__unix__) || defined(unix)) &amp;&amp; !defined(USG)
#include &lt;sys/param.h&gt;
#endif</programlisting>

        <para>加進 <filename>.c</filename> 檔案裡適當的位置。
          我們相信任何有定義這兩個符號的系統都有
          <filename>sys/param.h</filename>。如果發現有系統沒有，
          我們會很樂意知道的。請寄信到 &a.ports;。</para>

        <para>另一種方法是用 GNU Autoconf 的形式來做：</para>

        <programlisting>
#ifdef HAVE_SYS_PARAM_H
#include &lt;sys/param.h&gt;
#endif</programlisting>

        <para>別忘了這種方式要在 <filename>Makefile</filename> 裡的
          <makevar>CFLAGS</makevar> 加上
          <literal>-DHAVE_SYS_PARAM_H</literal>。</para>

        <para>一旦包括了 <filename>sys/param.h</filename>，可以用：</para>

        <programlisting>
#if (defined(BSD) &amp;&amp; (BSD &gt;= 199103))</programlisting>

        <para>來檢查程式是否在 4.3 Net2 code base 或更新版的上編譯(如
          FreeBSD 1.x、4.3/Reno、NetBSD 0.9、386BSD、BSD/386 1.1
          和之下的版本)。</para>

        <para>用：</para>

        <programlisting>
#if (defined(BSD) &amp;&amp; (BSD &gt;= 199306))</programlisting>

        <para>來檢查程式是否在 4.4 code base 或更新的基礎上編義(如
          FreeBSD 2.x、4.4、NetBSD 1.0、BSD/386 2.0 或這之上的版本)。</para>

        <para>對 4.4BSD-Lite2 code base 而言，<literal>BSD</literal>
          巨集指令的值是 <literal>199506</literal>。
          這個陳述只是為了提供訊息。它不應該被用來分辯單純以 4.4 Lite
          為基礎的 FreeBSD 版本以及融合了來自 4.4-Lite2 的改變的版本。
          這時後應該用 <literal>__FreeBSD__</literal>
          這個巨集指令來替代。</para>

        <para>Use sparingly:</para>

        <itemizedlist>
          <listitem>
            <para><literal>__FreeBSD__</literal> 定義在所有版本的 FreeBSD 裡。
              假如你做的改變<emphasis>只有</emphasis>影響到 FreeBSD 就用它。
              Porting gotchas like the use of <literal>sys_errlist[]</literal>
              vs <function>strerror()</function> are Berkeleyisms, not FreeBSD
              changes.</para>
          </listitem>

          <listitem>
            <para>在 FreeBSD 2.x 裡，<literal>__FreeBSD__</literal> 定為
              <literal>2</literal>。在更早的版本則為 <literal>1</literal>。
              較新的版本會提升這個值來配合它們的主版本編號。</para>
          </listitem>

          <listitem>
            <para>如果必須分辯 FreeBSD 1.x 系統和 FreeBSD 2.x 或 3.x
              系統間的不同，通常正確的解答是用上述的 <literal>BSD</literal>
              巨集指令。如果真的有專為 FreeBSD 的改變(如用到
              <command>ld</command>時的特殊共享函式選項)那就可以用
              <literal>__FreeBSD__</literal> 和 <literal>#if
                __FreeBSD__ &gt; 1</literal> 來認出 FreeBSD 2.x 和其之後的系統。
              如果需要更多細節來認出 2.0-RELEASE 之後的 FreeBSD 系統，
              可以用下面的方法：</para>

            <programlisting>
#if __FreeBSD__ &gt;= 2
#include &lt;osreldate.h&gt;
#    if __FreeBSD_version &gt;= 199504
         /* 2.0.5+ release specific code here */
#    endif
#endif</programlisting>

            <informaltable frame="none">
              <tgroup cols="2">
                <thead>
                  <row>
                    <entry>Release</entry>
                    <entry><literal>__FreeBSD_version</literal></entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry>2.0-RELEASE</entry>
                    <entry>119411</entry>
                  </row>

                  <row>
                    <entry>2.1-CURRENT</entry>
                    <entry>199501, 199503</entry>
                  </row>

                  <row>
                    <entry>2.0.5-RELEASE</entry>
                    <entry>199504</entry>
                  </row>

                  <row>
                    <entry>2.1 之前的 2.2-CURRENT</entry>
                    <entry>199508</entry>
                  </row>

                  <row>
                    <entry>2.1.0-RELEASE</entry>
                    <entry>199511</entry>
                  </row>

                  <row>
                    <entry>2.1.5 之前的 2.2-CURRENT</entry>
                    <entry>199512</entry>
                  </row>

                  <row>
                    <entry>2.1.5-RELEASE</entry>
                    <entry>199607</entry>
                  </row>

                  <row>
                    <entry>2.1.6 之前的 2.2-CURRENT</entry>
                    <entry>199608</entry>
                  </row>

                  <row>
                    <entry>2.1.6-RELEASE</entry>
                    <entry>199612</entry>
                  </row>

                  <row>
                    <entry>2.1.7-RELEASE</entry>
                    <entry>199612</entry>
                  </row>

                  <row>
                    <entry>2.2-RELEASE</entry>
                    <entry>220000</entry>
                  </row>

                  <row>
                    <entry>2.2.1-RELEASE</entry>
                    <entry>220000 (不變)</entry>
                  </row>

                  <row>
                    <entry>2.2.1-RELEASE 之後的 2.2-STABLE</entry>
                    <entry>220000 (不變)</entry>
                  </row>

                  <row>
                    <entry>2.2-STABLE after texinfo-3.9</entry>
                    <entry>221001</entry>
                  </row>

                  <row>
                    <entry>2.2-STABLE after top</entry>
                    <entry>221002</entry>
                  </row>

                  <row>
                    <entry>2.2.2-RELEASE</entry>
                    <entry>222000</entry>
                  </row>

                  <row>
                    <entry>2.2.2-RELEASE 之後的 2.2-STABLE</entry>
                    <entry>222001</entry>
                  </row>

                  <row>
                    <entry>2.2.5-RELEASE</entry>
                    <entry>225000</entry>
                  </row>

                  <row>
                    <entry>2.2.5-RELEASE 之後的 2.2-STABLE</entry>
                    <entry>225001</entry>
                  </row>

                  <row>
                    <entry>併入 ldconfig -R 之後的 2.2-STABLE</entry>
                    <entry>225002</entry>
                  </row>

                  <row>
                    <entry>2.2.6-RELEASE</entry>
                    <entry>226000</entry>
                  </row>

                  <row>
                    <entry>2.2.7-RELEASE</entry>
                    <entry>227000</entry>
                  </row>

                  <row>
                    <entry>2.2.7-RELEASE 之後的 2.2-STABLE</entry>
                    <entry>227001</entry>
                  </row>

                  <row>
                    <entry>semctl(2) 改變後的 2.2-STABLE</entry>
                    <entry>227002</entry>
                  </row>

                  <row>
                    <entry>2.2.8-RELEASE</entry>
                    <entry>228000</entry>
                  </row>

                  <row>
                    <entry>2.2.8-RELEASE 之後的 2.2-STABLE</entry>
                    <entry>228001</entry>
                  </row>

                  <row>
                    <entry>mount(2) 改變前的 3.0-CURRENT</entry>
                    <entry>300000</entry>
                  </row>

                  <row>
                    <entry>mount(2) 改變後的 3.0-CURRENT</entry>
                    <entry>300001</entry>
                  </row>

                  <row>
                    <entry>semctl(2) 改變後的 3.0-CURRENT</entry>
                    <entry>300002</entry>
                  </row>

                  <row>
                    <entry>ioctl arg 改變後的 3.0-CURRENT</entry>
                    <entry>300003</entry>
                  </row>

                  <row>
                    <entry>轉換為 ELF 後的 3.0-CURRENT</entry>
                    <entry>300004</entry>
                  </row>

                  <row>
                    <entry>3.0-RELEASE</entry>
                    <entry>300005</entry>
                  </row>

                  <row>
                    <entry>3.0-RELEASE 之後的 3.0-CURRENT</entry>
                    <entry>300006</entry>
                  </row>

                  <row>
                    <entry>3/4 分支後的 3.0-STABLE</entry>
                    <entry>300007</entry>
                  </row>

                  <row>
                    <entry>3.1-RELEASE</entry>
                    <entry>310000</entry>
                  </row>

                  <row>
                    <entry>3.1-RELEASE 後的 3.1-STABLE</entry>
                    <entry>310001</entry>
                  </row>

                  <row>
                    <entry>C++ constructor/destructor order 改變後的 3.1-STABLE
                      </entry>
                    <entry>310002</entry>
                  </row>

                  <row>
                    <entry>3.2-RELEASE</entry>
                    <entry>320000</entry>
                  </row>

                  <row>
                    <entry>3.2-STABLE</entry>
                    <entry>320001</entry>
                  </row>

                  <row>
                    <entry>binary-incompatible IPFW 和 socket 改變後的 3.2-STABLE
                      </entry>
                    <entry>320002</entry>
                  </row>

                  <row>
                    <entry>3.3-RELEASE</entry>
                    <entry>330000</entry>
                  </row>

                  <row>
                    <entry>3.3-STABLE</entry>
                    <entry>330001</entry>
                  </row>

                  <row>
                    <entry>mkstemps() 加進 libc 後的 3.3-STABLE</entry>
                    <entry>330002</entry>
                  </row>

                  <row>
                    <entry>3/4 分支後的 4.0-CURRENT</entry>
                    <entry>400000</entry>
                  </row>

                  <row>
                    <entry>動態連結器的管理改變後的 4.0-CURRENT
                      </entry>
                    <entry>400001</entry>
                  </row>

                  <row>
                    <entry>C++ constructor/destructor order 改變後的 4.0-CURRENT
                      </entry>
                    <entry>400002</entry>
                  </row>

                  <row>
                    <entry>dladdr(3) 起作用後的 4.0-CURRENT</entry>
                    <entry>400003</entry>
                  </row>

                  <row>
                    <entry>__deregister_frame_info 動態連結器的錯誤修正後的
                      4.0-CURRENT (整合 EGCS 1.1.2 後的 4.0-CURRENT 也是)
                    </entry>
                    <entry>400004</entry>
                  </row>

                  <row>
                    <entry>suser(9) API 改變後的 4.0-CURRENT
                      (newbus 之後的 4.0-CURRENT 也是)</entry>
                    <entry>400005</entry>
                  </row>

                  <row>
                    <entry>cdevsw registration 改變後的 4.0-CURRENT</entry>
                    <entry>400006</entry>
                  </row>

                  <row>
                    <entry>4.0-CURRENT after the addition of so_cred for
                      socket level credentials</entry>
                    <entry>400007</entry>
                  </row>

                  <row>
                    <entry>4.0-CURRENT after the addition of a poll syscall
                      wrapper to libc_r</entry>
                    <entry>400008</entry>
                  </row>

                  <row>
                    <entry>更換 kernel 的 <literal>dev_t</literal> 格式為
                    <literal>struct specinfo</literal> 指標後的 4.0-CURRENT
                      </entry>
                    <entry>400009</entry>
                  </row>

                  <row>
                    <entry>修正 jail(2) 的漏洞後的 4.0-CURRENT</entry>
                    <entry>400010</entry>
                  </row>

                  <row>
                    <entry><literal>sigset_t</literal> 的資料格式改變後的
                        4.0-CURRENT</entry>
                    <entry>400011</entry>
                  </row>

                  <row>
                    <entry>更新至 GCC 2.95.2 編譯器後的 4.0-CURRENT
                        </entry>
                    <entry>400012</entry>
                  </row>

                  <row>
                    <entry>4.0-CURRENT after adding pluggable linux-mode
                        ioctl handlers</entry>
                    <entry>400013</entry>
                  </row>

                  <row>
                    <entry>輸入 OpenSSL 後的 4.0-CURRENT</entry>
                    <entry>400014</entry>
                  </row>

                  <row>
                    <entry>GCC 2.95.2 裡的 C++ ABI 由預設的 -fno-vtable-thunks
                        改為 -fvtable-thunks 後的 4.0-CURRENT</entry>
                    <entry>400015</entry>
                  </row>

                </tbody>
              </tgroup>
            </informaltable>
          </listitem>
        </itemizedlist>

        <note>
          <para>注意一下有時後 2.2-STABLE 會以為自己是在 2.2.5-RELEASE 後的
            &ldquo;2.2.5-STABLE&rdquo;。原本該樣式是年份後緊接著月份，
            不過從 2.2 開始我們決定改為更直接的 主要的/次要的 系統。
            這是因為一些分支的平行發展讓簡單地用釋出日期來分類變得不可行。
            如果你正在做一個 port，不用擔心舊的 -CURRENT；
            它們會列在這就是為了讓你參考。</para>
        </note>

        <para>在已經做好的數百個 port 裡，只有少數一兩個情形應該已經用到了
          <literal>__FreeBSD__</literal>。只因為一個較早的 port
          弄亂了它並把它用錯地方不代表你也應該這麼做。</para>
      </sect3>

      <sect3>
        <title>在 <filename>bsd.port.mk</filename> 後寫東西</title>

        <para>不要在 <literal>.include &lt;bsd.port.mk&gt;</literal>
          這行後寫上任何東西。這通常可以藉由在你的 <filename>Makefile</filename>
          中間某處含有 <filename>bsd.port.pre.mk</filename> 和結尾有
          <filename>bsd.port.post.mk</filename> 來避免。</para>

        <note>
          <para>你必須含有 <filename>pre.mk</filename>/<filename>post.mk</filename>
            這一對或是只有 <filename>bsd.port.mk</filename>；
            不要把兩者混在一起。</para>
        </note>

        <para><filename>bsd.port.pre.mk</filename> 只有定義少數可以放在
          <filename>Makefile</filename> 用來測試的變數，
          <filename>bsd.port.post.mk</filename> 定義其餘的變數。</para>

        <para>這裡有幾個定義在 <filename>bsd.port.pre.mk</filename>
          裡的重要變數(這不是完整的列表，要看完整的請看
          <filename>bsd.port.mk</filename>)。</para>

        <informaltable frame="none">
          <tgroup cols="2">
            <thead>
              <row>
                <entry>變數</entry>
                <entry>描述</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><makevar>ARCH</makevar></entry>
                <entry>系統架構會藉由 <command>uname -m</command> 回傳(如
                  <literal>i386</literal>)</entry>
              </row>

              <row>
                <entry><makevar>OPSYS</makevar></entry>
                <entry>作業細統形式，由 <command>uname -s</command> 回傳(如
                  <literal>FreeBSD</literal>)</entry>
              </row>

              <row>
                <entry><makevar>OSREL</makevar></entry>
                <entry>作業系統的 release 版本(如 <literal>2.1.5</literal> 或
                  <literal>2.2.7</literal>)</entry>
              </row>

              <row>
                <entry><makevar>OSVERSION</makevar></entry>
                <entry>用數字表示的作業系統版本，跟
                  <link
                    linkend="porting-versions"><literal>__FreeBSD_version</literal></link> 一樣。</entry>
              </row>

              <row>
                <entry><makevar>PORTOBJFORMAT</makevar></entry>
                <entry>系統的物件格式(<literal>aout</literal> 或
                   <literal>elf</literal></entry>
              </row>

              <row>
                <entry><makevar>LOCALBASE</makevar></entry>
                <entry>&ldquo;local&rdquo; tree 的基底(如
                  <literal>/usr/local/</literal>)</entry>
              </row>

              <row>
                <entry><makevar>X11BASE</makevar></entry>
                <entry>&ldquo;X11&rdquo; tree 的基底(如
                  <literal>/usr/X11R6</literal>)</entry>
              </row>

              <row>
                <entry><makevar>PREFIX</makevar></entry>
                <entry>port 該把自己裝到哪裡(看 <link
                    linkend="porting-prefix">more on
                    <makevar>PREFIX</makevar></link>).</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <note>
          <para>如要必須定義變數 <makevar>USE_IMAKE</makevar>，
            <makevar>USE_X_PREFIX</makevar> 或 <makevar>MASTERDIR</makevar>，
            在包括 <filename>bsd.port.pre.mk</filename> 前做這件事。</para>
        </note>

        <para>這裡有幾個可以寫在 <filename>bsd.port.pre.mk</filename>
          後的例子；</para>

        <programlisting>
# no need to compile lang/perl5 if perl5 is already in system
.if ${OSVERSION} > 300003
BROKEN= perl is in system
.endif

# only one shlib version number for ELF
.if ${PORTOBJFORMAT} == "elf"
TCL_LIB_FILE=  ${TCL_LIB}.${SHLIB_MAJOR}
.else
TCL_LIB_FILE=  ${TCL_LIB}.${SHLIB_MAJOR}.${SHLIB_MINOR}
.endif

# software already makes link for ELF, but not for a.out
post-install:
.if ${PORTOBJFORMAT} == "aout"
       ${LN} -sf liblinpack.so.1.0 ${PREFIX}/lib/liblinpack.so
.endif</programlisting>
      </sect3>

      <sect3>
        <title>安裝額外的文件資料</title>

        <para>如果軟體有標準的 man 和 info 以外你認為對使用者有用的文件，
          把它安裝到 <filename><makevar>PREFIX</makevar>/share/doc</filename>
          下。如同前面的項目，這可以在 <maketarget>post-install</maketarget>
          的標的裡做到。</para>

        <para>為你的 port 建一個新的目錄。該目錄應該要能反應該 port 為何物。
          這通常意謂著 <makevar>PKGNAME</makevar> 減去版本的部份。
          然而，如果認為使用者可能同時安裝不同版本的 port，那就可以用整個
          <makevar>PKGNAME</makevar>。</para>

        <para>讓安裝的動作依賴變數 <makevar>NOPORTDOCS</makevar>
          以便使用者可以在 <filename>/etc/make.conf</filename> 讓它失用作用，
          如下：</para>

        <programlisting>
post-install:
.if !defined(NOPORTDOCS)
        ${MKDIR}${PREFIX}/share/doc/xv
        ${INSTALL_MAN} ${WRKSRC}/docs/xvdocs.ps ${PREFIX}/share/doc/xv
.endif</programlisting>

        <para>別忘了也把它們加進 <filename>pkg/PLIST</filename>！
          (在這邊不用擔心 <makevar>NOPORTDOCS</makevar>；目前 package
          沒有辦法從 <filename>/etc/make.conf</filename> 讀取變數。)</para>

        <para>也可以用 <filename>pkg/MESSAGE</filename> 這個檔讓安裝時顯示訊息。
          看 <link linkend="porting-message">使用
            <filename>pkg/MESSAGE</filename></link> 的章節來獲得更多細節。</para>

        <note>
          <para><filename>MESSAGE</filename> 不需要加進
            <filename>pkg/PLIST</filename> 裡。</para>
        </note>
      </sect3>

      <sect3>
        <title><makevar>DIST_SUBDIR</makevar></title>

        <para>不要讓 port 弄亂了 <filename>/usr/ports/distfiles</filename>。
          如果 port 需要抓很多檔案，或是含有檔名可能會和其它 port
          相衝的檔案(如，<filename>Makefile</filename>)，把
          <makevar>DIST_SUBDIR</makevar> 設為 port 的名稱(沒有版本的部份的
          <makevar>PKGNAME</makevar> 應該就行了)。這樣會把
          <makevar>DISTDIR</makevar> 從預設的 <filename>/usr/ports/distfiles</filename>
          改為 <filename>/usr/ports/distfiles/<makevar>DIST_SUBDIR</makevar></filename>，
          實際上並把 port 需要的所有東西都放進那個子目錄。</para>

        <para>它在主要的備份站 <filename>ftp.FreeBSD.org</filename>
          上也是看同名的子目錄。(在 <makevar>Makefile</makevar> 明確地設定
          <makevar>DISTDIR</makevar> 不會做到這一點，所以請用
          <makevar>DIST_SUBDIR</makevar>。)</para>

        <note>
          <para>這不會影響 Makefile 裡設定的 <makevar>MASTER_SITES</makevar>。
            </para>
        </note>
      </sect3>

      <sect3>
        <title>Package 的資訊</title>

        <para>把 package 的資訊包括到 <filename>pkg</filename> 裡，如.
          <filename>COMMENT</filename>，<filename>DESCR</filename>，和
          <filename>PLIST</filename>。</para>

        <note>
          <para>這些檔案已不再只用於包裝，現在即使設定了
            <makevar>NO_PACKAGE</makevar>
            這些檔案仍是<emphasis>必要的</emphasis>。</para>
        </note>
      </sect3>

      <sect3>
        <title>RCS 字串</title>

        <para>不要把 RCS 字串放進 patch 裡。當我們把檔案放進 ports tree
          時 CVS 會把它們切去，而當我們檢查時又一次，
          這樣它們會變得不一樣而且 patch 會失敗。RCS 字串由 dollar
          符號(<literal>&dollar;</literal>)圍起來，一般來說由
          <literal>&dollar;Id</literal> 或 <literal>&dollar;RCS</literal>
          起頭。</para>
      </sect3>

      <sect3>
        <title>遞迴的 diff</title>

        <para>對 <command>diff</command> 使用遞迴選項(<option>-r</option>)
          <command>diff</command> 來產生 patch 會好多了，不過請看一下最後的
          patch 來確定沒有任何不需要的垃圾在裡面。尤其是兩個備份檔間的 diff，
          和當 port 用 <command>Imake</command> 或 GNU
          <command>configure</command> 等等時的 <filename>Makefiles</filename>
          也不需要而該砍掉。如果必須編輯 <filename>configure.in</filename>
          並執行 <command>autoconf</command> 來重新產生
          <command>configure</command>，不要做 <command>configure</command>
          的 diff (這通常會數千行！)；定義 <literal>USE_AUTOCONF=yes</literal>
          並做 <filename>configure.in</filename> 的 diff。</para>

        <para>同樣地，如果必須砍掉檔案，那就寫在 <maketarget>post-extract</maketarget>
          的標的裡來做而不要弄為 patch 的一部份。如果對最終的 diff 滿意，
          請把它分割成一個 patch 就對應一個原始檔。</para>
      </sect3>

      <sect3 id="porting-prefix">
        <title><makevar>PREFIX</makevar></title>

        <para>試著讓 port 安裝至相對於 <makevar>PREFIX</makevar>
          (這個值應該設為 <makevar>LOCALBASE</makevar> (預設是
          <filename>/usr/local</filename>)，除非已經設了
          <makevar>USE_X_PREFIX</makevar> 或 <makevar>USE_IMAKE</makevar>，
          這樣的話就應該是 <makevar>X11BASE</makevar> (預設是
          <filename>/usr/X11R6</filename>)。)的位置。</para>

        <para>不要把 <filename>/usr/local</filename> 或
          <filename>/usr/X11R6</filename> 寫死在程式碼的任何地方，
          這會讓 port 更有彈性而且可以迎合其它站的需求。對用
          <command>imake</command> 的 X port 來說，這是自動產生的；
          不然往往可以僅藉由把 port 裡各個 scripts/Makefiles 出現
          <filename>/usr/local</filename> (沒有用 imake 的 X port 就是
          <filename>/usr/X11R6</filename>) 的地方取代為去讀取
          <makevar>PREFIX</makevar> 來達成，
          因為這個變數會自動地往下傳至建立與安裝過程中的每個階段。</para>

        <para>不要設 <makevar>USE_X_PREFIX</makevar>，除非你的 port 真的需要它
          (例如，它連結 X 的函式或它必須參考到 <makevar>X11BASE</makevar>
          裡的檔案)。</para>

        <para><makevar>PREFIX</makevar> 這個變數可以在你的
          <filename>Makefile</filename> 或使用者的環境裡重新指定。然而，
          在單獨 port 的 <filename>Makefiles</filename>
          明確地設定這個變數是相當令人感到氣餒的。</para>

        <para>同樣地，用上面提到的變數來參考其它 port 的程式/檔案，
          而非用明確的路徑名稱。舉個例，如果 port 需要一個完整的
          <command>less</command> 路徑名稱做為巨集 <literal>PAGER</literal>，
          用編譯器的旗標：

          <programlisting>
-DPAGER=\"&dollar;{PREFIX}/bin/less\"</programlisting>

          或

          <programlisting>
-DPAGER=\"&dollar;{LOCALBASE}/bin/less\"</programlisting>

          如果這是一個 X port，取代掉 <literal>-DPAGER=\"/usr/local/bin/less\"</literal>。
          這樣假如系統管理者把整個 `/usr/local' tree 移到其它地方，
          它會有較佳的機會可以運作。</para>
      </sect3>

      <sect3>
        <title>子目錄</title>

        <para>試著讓 port 把東西放到 <makevar>PREFIX</makevar> 下正確的子目錄。
          有些 port 把所有東西聚在並放進與 port 同名的子目錄，這是不對的。
          同樣地，有很多 port 把 binaries，header files 和 manual pages
          以外的所有東西放到 <filename>lib</filename> 的一個子目錄下，這對 BSD
          的模範並不是個好兆頭。這裡面有很多檔案都應該移到下面所列位置的其中一個：
          <filename>etc</filename> (setup/configuration 檔)，
          <filename>libexec</filename> (內部啟動的可執行檔)，
          <filename>sbin</filename> (superusers/managers 用的可執行檔)
          <filename>info</filename> (為 info 瀏覽器做的文件) 或
          <filename>share</filename> (與架構無關的檔案)。詳細資料參考 man
          &man.hier.7;，支配 <filename>/usr</filename>
          的規則有相當多的部份也適用在 <filename>/usr/local</filename>。
          除了處理 USENET &ldquo;news&rdquo; 的 port 以外。它們以
          <filename><makevar>PREFIX</makevar>/news</filename> 為檔案目的地。
          </para>
      </sect3>

      <sect3 id="porting-cleaning">
        <title>清理空目錄</title>

        <para>當 port 被反安裝時讓它能清理乾淨。這通常藉由為每個明確地由 port
          建立的目錄加上 <literal>@dirrm</literal> 這幾行來達成。
          在刪除 parent 目錄前必須先刪除子目錄。</para>

        <programlisting>
 :
lib/X11/oneko/pixmaps/cat.xpm
lib/X11/oneko/sounds/cat.au
 :
@dirrm lib/X11/oneko/pixmaps
@dirrm lib/X11/oneko/sounds
@dirrm lib/X11/oneko</programlisting>

        <para>然而有時後 <literal>@dirrm</literal> 會出現錯誤因為其它的 port
          也在共用同一個子目錄。可以從 <literal>@unexec</literal> 呼叫
          <command>rmdir</command> 來移除空目錄而不出現警告。</para>

        <programlisting>
@unexec rmdir %D/share/doc/gimp 2>/dev/null || true</programlisting>

        <para>這將不會印出任何錯誤訊息，也不會造成 <command>pkg_delete</command>
          不正常跳出即使 <filename><makevar>PREFIX</makevar>/share/doc/gimp</filename>
          不是空的，由於其它 port 把一些檔案裝在裡面。</para>
      </sect3>

      <sect3>
        <title>UIDs</title>

        <para>如果需要安裝的系統上有特定的某使用者，讓 <filename>pkg/INSTALL</filename>
          script 呼叫 <command>pw</command> 來自動建立它。例子可在
          <filename>net/cvsup-mirror</filename> 看到。</para>

        <para>如果 port 安裝一個 binary package
          時必須使用與編譯時相同的使用者/群組(user/group) ID 編號，
          那就必須從 50 到 99 選擇一個未被佔用的 UID 並登記它。
          例子可到 <filename>japanese/Wnn</filename> 看。</para>

        <para>確定你沒有用一個已經被系統或其它 port 佔用的 UID。
          這裡是現在 50 到 99 間的 UID 的列表。</para>

        <programlisting>
majordom:*:54:54:Majordomo Pseudo User:/usr/local/majordomo:/nonexistent
cyrus:*:60:60:the cyrus mail server:/nonexistent:/nonexistent
gnats:*:61:1:GNATS database owner:/usr/local/share/gnats/gnats-db:/bin/sh
uucp:*:66:66:UUCP pseudo-user:/var/spool/uucppublic:/usr/libexec/uucp/uucico
xten:*:67:67:X-10 daemon:/usr/local/xten:/nonexistent
pop:*:68:6:Post Office Owner (popper):/nonexistent:/nonexistent
wnn:*:69:7:Wnn:/nonexistent:/nonexistent
ifmail:*:70:66:Ifmail user:/nonexistent:/nonexistent
pgsql:*:70:70:PostgreSQL pseudo-user:/usr/local/pgsql:/bin/sh
ircd:*:72:72:IRCd hybrid:/nonexistent:/nonexistent
alias:*:81:81:QMail user:/var/qmail/alias:/nonexistent
qmaill:*:83:81:QMail user:/var/qmail:/nonexistent
qmaild:*:82:81:QMail user:/var/qmail:/nonexistent
qmailq:*:85:82:QMail user:/var/qmail:/nonexistent
qmails:*:87:82:QMail user:/var/qmail:/nonexistent
qmailp:*:84:81:QMail user:/var/qmail:/nonexistent
qmailr:*:86:82:QMail user:/var/qmail:/nonexistent
msql:*:87:87:mSQL-2 pseudo-user:/var/db/msqldb:/bin/sh
mysql:*:88:88:MySQL Daemon:/var/db/mysql:/sbin/nologin</programlisting>

        <para>當提出一個要預留這範圍內新的 UID 或 GID 的 port (或升級)時，
          請包括進一個公告。這會容許我們把預留的 ID 列表保持在最新狀態。</para>
      </sect3>

      <sect3>
        <title>合理地做事</title>

        <para><filename>Makefile</filename> 應該簡單並合理地做事。
          如果能讓兩三行變得更短或更合裡，那就這麼做吧。這些例子包括用
          <literal>.if</literal> construct 來替代 shell，如果可以重新定義
          <makevar>EXTRACT*</makevar> 就不要再定義
          <maketarget>do-extract</maketarget>，還有用
          <makevar>GNU_CONFIGURE</makevar> 來替代 <literal>CONFIGURE_ARGS
            += --prefix=&dollar;{PREFIX}</literal>。</para>
      </sect3>

      <sect3>
        <title>尊重 <makevar>CFLAGS</makevar></title>

        <para>port 應該尊重 <makevar>CFLAGS</makevar> 這個變數。
          如果沒有請加上 <literal>NO_PACKAGE=ignores cflags</literal>
          到 <filename>Makefile</filename> 裡。</para>
      </sect3>

      <sect3>
        <title>Configuration 檔</title>

        <para>如果 port 需要放一些 configuration 檔在
          <filename><makevar>PREFIX</makevar>/etc</filename> 裡，
          <emphasis>不要</emphasis>只是安裝它們並列在
          <filename>pkg/PLIST</filename> 裡。這會造成 <command>pkg_delete</command>
          刪除使用者費心編輯的檔案和被新的安裝完全消除。</para>

        <para>反之，安裝有字尾語的樣品檔
          (<filename><replaceable>filename</replaceable>.sample</filename>
          就不錯)並印出一段<link linkend="porting-message">message</link>
          指明使用者在該軟體能運作錢必須先拷貝並編輯該檔案。</para>
      </sect3>

      <sect3>
        <title>Portlint</title>

        <para>在提出或 commit 之前用 <link
            linkend="porting-portlint"><command>portlint</command></link>
          檢查成果。</para>
      </sect3>

      <sect3>
        <title>回饋</title>

        <para>把適合的改變/patch 寄給原先的作者/maintainer
          以在下一個釋出的程式碼包含進去。這只會讓你在下一版的工作更輕鬆。
          </para>
      </sect3>

      <sect3>
        <title>Miscellanea</title>

        <para><filename>pkg/DESCR</filename>，<filename>pkg/COMMENT</filename>，
          和 <filename>pkg/PLIST</filename> 每個檔都應該加倍檢查。
          如果重新檢視一個 port 並覺得可以表達的更好，就做吧。</para>

        <para>不要複製額外的 GNU 大眾公用版權(GPL) 的複本到我們的系統，拜托。
          </para>

        <para>請小心注意任何的法律議題！不要讓我們違法散佈軟體！</para>
      </sect3>

      <sect3>
        <title>如果感到困惑&hellip;</title>

        <para>在問我們任何問題前先看現存的例子和
          <filename>bsd.port.mk</filename> 檔！
          <!-- smiley --><emphasis>;)</emphasis></para>

        <para>如果有任何麻煩就問我們吧！不要用頭去撞牆！<!-- smiley
          --><emphasis>:-)</emphasis></para>
      </sect3>
    </sect2>

    <sect2 id="porting-samplem">
      <title>一個 <filename>Makefile</filename> 的樣品</title>

      <para>這裡有個 <filename>Makefile</filename> 的樣品可以用來創造一個新的
        port。確定已移除所有額外的說明(方括弧內的東西)！</para>

      <para>建議你跟著這個格式(變數的次序，章節間的空行等等)。
        這個格式被設計於容易找到大部份的重要訊息。我們建議用 <link
          linkend="porting-portlint">portlint</link> 來檢查
        <filename>Makefile</filename>。</para>

      <programlisting>
[檔頭...只是讓我們容易確認 port。]
# New ports collection makefile for:   xdvi
[當升級一個 port 時 version required 的檔頭應該更新。]
# Version required:    pl18 [things like "1.5alpha" are fine here too]
[這是這個 Makefile 的第一版創造時的日期。更新 port 時絕不要改變這個。]
# Date created:                26 May 1995
[這是做出最初的 port 給 FreeBSD 的人，尤其是寫出這個 Makefile 第一版的人。
記住，以後升級 port 時這不應該改變。]
# Whom:                        Satoshi Asami &lt;asami@FreeBSD.org&gt;
#
# &dollar;FreeBSD&#36;
[ ^^^^^^^^^ 當它被 commit 到我們的貯藏庫時會被 CVS 自動地以 RCS ID 字串取代。 
如果升級 port，不要把這行改回 "&dollar;FreeBSD&dollar;"。CVS 會自動處理。]
#
       
[用來描述 port 本身和主站的章節 - DISTNAME 永遠最先，跟著是 PKGNAME(如果需要)，
 CATEGORIES，然後是 MASTER_SITES，MASTER_SITE_SUBDIR 可以跟在其後。
 在這些之後，EXTRACT_SUFX 或 DISTFILES 中之一也可以詳載。]
DISTNAME=      xdvi
PKGNAME=       xdvi-pl18
CATEGORIES=    print
[如果不是用 MASTER_SITE_* 巨集別忘了最後的斜線 ("/")！] 
MASTER_SITES=  ${MASTER_SITE_XCONTRIB}
MASTER_SITE_SUBDIR= applications
[如果程式碼不是用標準的 ".tar.gz" 結構就設定這個]
EXTRACT_SUFX=  .tar.Z
       
[散佈的 patch 的章節 -- 可以空著]
PATCH_SITES=   ftp://ftp.sra.co.jp/pub/X11/japanese/
PATCHFILES=    xdvi-18.patch1.gz xdvi-18.patch2.gz
       
[maintainer; *委託管理的*！這是一個使用者有問題和 bug 回報時聯絡的人
 (最好有 commit 的特權) - 這個人應該是 porter 或是可以即刻合理地傳達問題給起初的
 porter 的人。如果真的不想在這寫上位址，就設為 "ports@FreeBSD.org"。]
MAINTAINER=    asami@FreeBSD.org
       
[dependencies -- 可以空著]
RUN_DEPENDS=   gs:${PORTSDIR}/print/ghostscript
LIB_DEPENDS=   Xpm.5:${PORTSDIR}/graphics/xpm
       
[這個章節是為了不屬於上面任一章的其它標準的 bsd.port.mk 變數]
[如果在 configure，建立，安裝...的過程中會問問題]
IS_INTERACTIVE=        yes
[如果它解到 ${DISTNAME} ... 以外的目錄]
WRKSRC=                ${WRKDIR}/xdvi-new
[如果散佈的 patch 沒有相對於 ${WRKSRC}，可能得費心處理這個]
PATCH_DIST_STRIP=      -p1
[如果它需要執行一個由 GNU autoconf 產生的 "configure" script]
GNU_CONFIGURE= yes
[如果它須要用 GNU make 來建立...，而不是 /usr/bin/make]
USE_GMAKE=     yes
[如果它是一個 X 應用程式且需要執行 "xmkmf -a"]
USE_IMAKE=     yes
[et cetera.]
       
[用在下面規則的非標準變數]
MY_FAVORITE_RESPONSE=  "yeah, right"
       
[再來是特殊的規則，以它們被呼叫的順序排列]
pre-fetch:
        i go fetch something, yeah
       
post-patch:
        i need to do something after patch, great
       
pre-install:
        and then some more stuff before installing, wow
       
[然後就是結尾了]
.include &lt;bsd.port.mk&gt;</programlisting>
    </sect2>

    <sect2 id="porting-autoplist">
      <title>Automated package list creation</title>

      <para>首先，確定 port 已幾乎完成，只缺 <filename>PLIST</filename>。
        創造一個空的 <filename>PLIST</filename>。</para>

      <screen>&prompt.root; <userinput>touch PLIST</userinput></screen>

      <para>再來，創造一組 port 可以安裝的新目錄，並安裝任何的 dependency。
        </para>

      <screen>&prompt.root; <userinput>mtree -U -f /etc/mtree/BSD.local.dist -d -e -p /var/tmp/<replaceable>port-name</replaceable></userinput>
&prompt.root; <userinput>make depends PREFIX=/var/tmp/<replaceable>port-name</replaceable></userinput></screen>

      <para>把目錄的結構存在一個新檔案裡。</para>

      <screen>&prompt.root; <userinput>(cd /var/tmp/<replaceable>port-name</replaceable> && find * \! -type d) &gt; OLD-DIRS</userinput></screen>

      <para>如果 port 尊敬 <makevar>PREFIX</makevar> (它應該如此)
        接著就可以安裝 port 並創造 package 列表。</para>

      <screen>&prompt.root; <userinput>make install PREFIX=/var/tmp<replaceable>port-name</replaceable></userinput>
&prompt.root; <userinput>(cd /var/tmp/<replaceable>port-name</replaceable> && find * \! -type d) &gt; pkg/PLIST</userinput></screen>

      <para>你也必須把任何最新創造的目錄加進包裝列表。</para>

      <screen>&prompt.root; <userinput>(cd /var/tmp/<replaceable>port-name && find * -type d) | comm -13 OLD-DIRS - | sed -e 's#^#@dirrm#' &gt;&gt; pkg/PLIST</replaceable></userinput></screen>

      <para>最後，必須自己動手整理包裝列表。當我說這是全自動時我撒了個謊。
        Manual pages 應該列在 port 的 <filename>Makefile</filename> 裡的
        <makevar>MAN<replaceable>n</replaceable></makevar> 下，
        而不是在包裝列表裡。使用者的 configuration 檔應該移除，或是安裝為
        <filename><replaceable>filename</replaceable>.sample</filename>。
        任何 port 安裝的函式應該如同 <link linkend="porting-ldconfig">ldconfig</link>
        該節所詳述的方式列出。</para>
    </sect2>

    <sect2 id="porting-pkgname">
      <title>Package 的名稱</title>

      <para>接下來是在為 package 命名時應遵守的慣例。這是為了讓我們的 package
        的目錄容易搜尋，因為已經有太多太多的 package，
        假如這傷到他們的眼睛那他們就會避開了！</para> 

      <para>Package 的名稱應該看起來像
        <filename><replaceable>language-</replaceable>name<replaceable>-compiled.specifics</replaceable><replaceable>-version.numbers</replaceable></filename>.</para>

      <para>如果 <makevar>DISTNAME</makevar> 看起來不像這個，就把
        <makevar>PKGNAME</makevar> 設為這種格式。</para>

      <orderedlist>
        <listitem>
          <para>FreeBSD 盡力去支援使用者的本地語言。如果 port 指定給某特定語言，
            <replaceable>language-</replaceable> 的部份就應該是該語言由 ISO-639
            所定義的兩個字母的縮寫。例如 Japanese 是 <literal>ja</literal>，
            Russian 是 <literal>ru</literal>，Vietnamese 是
            <literal>vi</literal>，hinese 是 <literal>zh</literal>，
            Korean 是 <literal>ko</literal>，而 German 是
            <literal>de</literal>。</para>
        </listitem>

        <listitem>
          <para><filename>name</filename> 的部份應該全是小寫，除了真的很大的
            package (裡面有很多程式)。如 XFree86 (沒錯，真的有這個 port，
            查一下吧) 和 ImageMagick 就是這一類。否則的話，把名字
            (或至少第一個字母)轉成小寫。如果大寫字母對名稱很重要(例如像
            <literal>R</literal> 或 <literal>V</literal> 有一個字母的名稱)
            你可以自己斟酌使用大寫字母。為 Perl 5 的模組命名傳統上會預先加上
            <literal>p5-</literal> 並把雙冒號的分隔轉為連字號；例如
            <literal>Data::Dumper</literal> 模組變為
            <literal>p5-Data-Dumper</literal>。如果有爭議的軟體名稱中有
            數字，連字號，或底線，也可以把它們都包括進去
            (就像 <literal>kinput2</literal>)。</para>
        </listitem>

        <listitem>
          <para>如果 port 可以用不同的 <link
              linkend="porting-masterdir">hardcoded defaults</link> 建立
            (通常是一個 port 的家族的目錄名稱的一部份)，
            <replaceable>-compiled.specifics</replaceable> 的部份應該聲明了
            compiled-in 的預設值 (連字號是選擇性的)。例如紙張大小和字型單元。
            </para>
        </listitem>

        <listitem>
          <para>version 字串應該是句點分隔的整數和一個照順序的小寫字母。
            唯一的例外是 <literal>pl</literal> (表示 `patchlevel') 字串，
            這<emphasis>唯有</emphasis>當軟體沒有主要和次要的版本編號才可以用。
            </para>
        </listitem>
      </orderedlist>

      <para>這裡有些如何把 <makevar>DISTNAME</makevar> 轉換成合適的
        <makevar>PKGNAME</makevar> 的(真實的)例子：</para>

      <informaltable frame="none">
        <tgroup cols="3">
          <thead>
            <row>
              <entry>發行版本的名稱</entry>
              <entry>Package 名稱</entry>
              <entry>原因</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>mule-2.2.2.</entry>
              <entry>mule-2.2.2</entry>
              <entry>不用改</entry>
            </row>

            <row>
              <entry>XFree86-3.1.2</entry>
              <entry>XFree86-3.1.2</entry>
              <entry>不用改</entry>
            </row>

            <row>
              <entry>EmiClock-1.0.2</entry>
              <entry>emiclock-1.0.2</entry>
              <entry>單一程式不用大寫名稱</entry>
            </row>

            <row>
              <entry>gmod1.4</entry>
              <entry>gmod-1.4</entry>
              <entry>版本編號前需要一個連字號</entry>
            </row>

            <row>
              <entry>xmris.4.0.2</entry>
              <entry>xmris-4.0.2</entry>
              <entry>版本編號前需要一個連字號</entry>
            </row>

            <row>
              <entry>rdist-1.3alpha</entry>
              <entry>rdist-1.3a</entry>
              <entry>不能有像 <literal>alpha</literal> 的字串</entry>
            </row>

            <row>
              <entry>es-0.9-beta1</entry>
              <entry>es-0.9b1</entry>
              <entry>不能有像 <literal>beta</literal> 的字串</entry>
            </row>

            <row>
              <entry>v3.3beta021.src</entry>
              <entry>tiff-3.3</entry>
              <entry>這倒底是什麼東西？</entry>
            </row>

            <row>
              <entry>tvtwm</entry>
              <entry>tvtwm-pl11</entry>
              <entry>一定要有版本字串</entry>
            </row>

            <row>
              <entry>piewm</entry>
              <entry>piewm-1.0</entry>
              <entry>一定要有版本字串</entry>
            </row>

            <row>
              <entry>xvgr-2.10pl1</entry>
              <entry>xvgr-2.10.1</entry>
              <entry>唯有沒主要/次要的版本編號才可用 <literal>pl</literal>
                </entry>
            </row>

            <row>
              <entry>gawk-2.15.6</entry>
              <entry>ja-gawk-2.15.6</entry>
              <entry>日語的版本</entry>
            </row>

            <row>
              <entry>psutils-1.13</entry>
              <entry>psutils-letter-1.13</entry>
              <entry>Package 編議時已寫死的紙張大小</entry>
            </row>

            <row>
              <entry>pkfonts</entry>
              <entry>pkfonts300-1.0</entry>
              <entry>300dpi 字型的 package</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>如果在原始的程式碼裡完全沒有版本資訊的痕跡，
        而且起初的作者也不大可能曾經釋出其它版本，就把版本的字串設為
        <literal>1.0</literal> (就像上面的例子 piewm)。
        否則就問起初的作者或用日期字串
        (<literal><replaceable>yy</replaceable>.<replaceable>mm</replaceable>.<replaceable>dd</replaceable></literal>)
        當版本。</para>
    </sect2>

    <sect2 id="porting-categories">
        <title>種類</title>

      <para>如同已知，port 以數個種類來分類。不過要讓這發揮功效，porter
        和使用者了解每個種類而且我們決定每個種類要放什麼是很重要的。</para>

      <sect3>
        <title>現在的分類列表</title>

        <para>首先，這是現在 port 的種類的列表。以星號(<literal>*</literal>)
          標示的是<emphasis>虛擬的</emphasis>種類&mdash;那些在 ports tree
          裡並沒有相對應的子目錄。</para>

        <note>
          <para>而非虛擬的種類，可以在該子目錄裡的
          <filename>pkg/COMMENT</filename> 找到一行的描述(如
            <filename>archivers/pkg/COMMENT</filename>)。</para>
        </note>

        <informaltable frame="none">
          <tgroup cols="2">
            <thead>
              <row>
                <entry>種類</entry>
                <entry>描述</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><filename>afterstep*</filename></entry>
                <entry>支援 AfterStep 視窗管理員的 port</entry>
              </row>

              <row>
                <entry><filename>archivers</filename></entry>
                <entry>檔案處理的工具。</entry>
              </row>

              <row>
                <entry><filename>astro</filename></entry>
                <entry>天文的 port。</entry>
              </row>

              <row>
                <entry><filename>audio</filename></entry>
                <entry>聲音的支援。</entry>
              </row>

              <row>
                <entry><filename>benchmarks</filename></entry>
                <entry>效能評比的工具。</entry>
              </row>

              <row>
                <entry><filename>biology</filename></entry>
                <entry>有關生物的軟體。</entry>
              </row>

              <row>
                <entry><filename>cad</filename></entry>
                <entry>電腦輔助設計的工具。</entry>
              </row>

              <row>
                <entry><filename>chinese</filename></entry>
                <entry>中文的支援。</entry>
              </row>

              <row>
                <entry><filename>comms</filename></entry>
                <entry>通訊軟體。大部份的軟體是用串列埠交談。</entry>
              </row>

              <row>
                <entry><filename>converters</filename></entry>
                <entry>字碼的轉換器。</entry>
              </row>

              <row>
                <entry><filename>databases</filename></entry>
                <entry>資料庫。</entry>
              </row>

              <row>
                <entry><filename>deskutils</filename></entry>
                <entry>電腦發明前在桌上的東西。</entry>
              </row>

              <row>
                <entry><filename>devel</filename></entry>
                <entry>發展工具。不要只因為它們是函式就把函式放在這&mdash;
                  除非它們真的不屬於其它地方，否則它們不該在這種類裡。</entry>
              </row>

              <row>
                <entry><filename>editors</filename></entry>
                <entry>一般的編輯器。特殊用途的編輯器在那些工具的區域裡
                  (例如，數學公式的編輯器會在 <filename>math</filename>)。
                  </entry>
              </row>

              <row>
                <entry><filename>elisp</filename></entry>
                <entry>Emacs-lisp 的 port。</entry>
              </row>

              <row>
                <entry><filename>emulators</filename></entry>
                <entry>其它作業系統的模擬器。終端機(terminal)的模擬器
                  <emphasis>不</emphasis>屬於這裡&mdash;以 X
                  為基礎的應該在 <filename>x11</filename> 而文字基礎的不是在
                  <filename>comms</filename> 就是 <filename>misc</filename>，
                  視其確實的功能而定。</entry>
              </row>

              <row>
                <entry><filename>ftp</filename></entry>
                <entry>FTP 客戶端和伺服器端的工具。如果 port 可與 FTP 和 HTTP
                  交談，把它以 <filename>www</filename> 為次要的分類放在
                  <filename>ftp</filename>。</entry> 
              </row>

              <row>
                <entry><filename>games</filename></entry>
                <entry>遊戲。</entry>
              </row>

              <row>
                <entry><filename>german</filename></entry>
                <entry>德語的支援。</entry>
              </row>

              <row>
                <entry><filename>gnome*</filename></entry>
                <entry>來自 GNU Object Model Environment (GNOME) Project
                  的 port。</entry>
              </row>

              <row>
                <entry><filename>graphics</filename></entry>
                <entry>圖形工具。</entry>
              </row>

              <row>
                <entry><filename>irc</filename></entry>
                <entry>Internet Chat Relay 的工具。</entry>
              </row>

              <row>
                <entry><filename>japanese</filename></entry>
                <entry>日語的支援。</entry>
              </row>

              <row>
                <entry><filename>java</filename></entry>
                <entry>Java 語言的支援。</entry>
              </row>

              <row>
                <entry><filename>kde*</filename></entry>
                <entry>來自 K Desktop Environment (KDE) Project
                  的 port。</entry>
              </row>

              <row>
                <entry><filename>korean</filename></entry>
                <entry>韓語的支援。</entry>
              </row>

              <row>
                <entry><filename>lang</filename></entry>
                <entry>程式語言。</entry>
              </row>

              <row>
                <entry><filename>mail</filename></entry>
                <entry>郵件軟體。</entry>
              </row>

              <row>
                <entry><filename>math</filename></entry>
                <entry>數值運算的軟體和其它的數學工具。</entry>
              </row>

              <row>
                <entry><filename>mbone</filename></entry>
                <entry>MBone 的應用程式。</entry>
              </row>

              <row>
                <entry><filename>misc</filename></entry>
                <entry>各式各樣的工具&mdash;基本上是不屬於任何地方的東西。
                  這是唯一不應該出現其它非虛擬種類的分類。如果你在
                  <makevar>CATEGORIES</makevar> 那行有 <literal>misc</literal>
                  以外的東西，那你可以放心地刪除 <literal>misc</literal>
                  並把 port 放進另一個子目錄！</entry>
              </row>

              <row>
                <entry><filename>net</filename></entry>
                <entry>各式各樣的網路軟體。</entry>
              </row>

              <row>
                <entry><filename>news</filename></entry>
                <entry>USENET news 的軟體。</entry>
              </row>

              <row>
                <entry><filename>offix*</filename></entry>
                <entry>來自 OffiX 套件的 port。</entry>
              </row>

              <row>
                <entry><filename>palm</filename></entry>
                <entry>3Com Palm(tm) 系列的軟體支援。</entry>
              </row>

              <row>
                <entry><filename>perl5*</filename></entry>
                <entry>需要 perl 第五版才能執行的 port。</entry>
              </row>

              <row>
                <entry><filename>plan9*</filename></entry>
                <entry>Plan9 的各種程式。</entry>
              </row>

              <row>
                <entry><filename>print</filename></entry>
                <entry>列印軟體。桌面出版的工具也屬於這裡
                  (previewers 等等)。</entry>
              </row>

              <row>
                <entry><filename>python*</filename></entry>
                <entry>用 python 寫的軟體。</entry>
              </row>

              <row>
                <entry><filename>russian</filename></entry>
                <entry>俄語的支援。</entry>
              </row>

              <row>
                <entry><filename>security</filename></entry>
                <entry>電腦安全的工具。</entry>
              </row>

              <row>
                <entry><filename>shells</filename></entry>
                <entry>命令列下的 shell。</entry>
              </row>

              <row>
                <entry><filename>sysutils</filename></entry>
                <entry>系統工具。</entry>
              </row>

              <row>
                <entry><filename>tcl75*</filename></entry>
                <entry>用 Tcl 7.5 版執行的 port。</entry>
              </row>

              <row>
                <entry><filename>tcl76*</filename></entry>
                <entry>用 Tcl 7.6 版執行的 port。</entry>
              </row>

              <row>
                <entry><filename>tcl80*</filename></entry>
                <entry>用 Tcl 8.0 版執行的 port。</entry>
              </row>

              <row>
                <entry><filename>tcl81*</filename></entry>
                <entry>用 Tcl 8.1 版執行的 port。</entry>
              </row>

              <row>
                <entry><filename>textproc</filename></entry>
                <entry>文字處理的工具。它不包括桌面出版的工具，
                  那屬於 print/。</entry>
              </row>

              <row>
                <entry><filename>tk41*</filename></entry>
                <entry>用 Tk 4.1 版執行的 port。</entry>
              </row>

              <row>
                <entry><filename>tk42*</filename></entry>
                <entry>用 Tk 4.2 版執行的 port。</entry>
              </row>

              <row>
                <entry><filename>tk80*</filename></entry>
                <entry>用 Tk 8.0 版執行的 port。</entry>
              </row>

              <row>
                <entry><filename>tk81*</filename></entry>
                <entry>用 Tk 8.1 版執行的 port。</entry>
              </row>

              <row>
                <entry><filename>tkstep80*</filename></entry>
                <entry>用 TkSTEP 8.0 版執行的 port。</entry>
              </row>

              <row>
                <entry><filename>vietnamese</filename></entry>
                <entry>越南語的支援。</entry>
              </row>

              <row>
                <entry><filename>windowmaker*</filename></entry>
                <entry>支援 WindowMaker 視窗管理員的 port</entry>
              </row>

              <row>
                <entry><filename>www</filename></entry>
                <entry>跟 World Wide Web 有關的軟體。HTML 語言的支援也屬於這裡。
                  </entry>
              </row>

              <row>
                <entry>x11</entry>
                <entry>X window system 和它的朋友們。
                  這個種類只給直接支援視窗系統的軟體。不要把平常的 X
                  應用程式放在這。如果 port 是個 X 應用程式，
                  定義<makevar>USE_XLIB</makevar> (包含有
                  <makevar>USE_IMAKE</makevar>) 並把它放在適當的種類。
                  同樣地，它們裡面有很多屬於其它的
                  <filename>x11-*</filename> 種類(看下面)。</entry>
              </row>

              <row>
                <entry><filename>x11-clocks</filename></entry>
                <entry>X11 的時鐘。</entry>
              </row>

              <row>
                <entry><filename>x11-fm</filename></entry>
                <entry>X11 的檔案管理員。</entry>
              </row>

              <row>
                <entry><filename>x11-fonts</filename></entry>
                <entry>X11 的字型和字型工具。</entry>
              </row>

              <row>
                <entry><filename>x11-servers</filename></entry>
                <entry>X11 servers.</entry>
              </row>

              <row>
                <entry><filename>x11-toolkits</filename></entry>
                <entry>X11 toolkits.</entry>
              </row>

              <row>
                <entry><filename>x11-wm</filename></entry>
                <entry>X11 視窗管理員。</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </sect3>

      <sect3>
        <title>選擇正確的種類</title>

        <para>因為有很多的種類重疊，你必須選擇何者為 port 首要的種類。
          有幾個規則支配著這個議題。這裡有份優先權的列表，其優先權依序遞減。
          </para>

        <itemizedlist>
          <listitem>
            <para>特定語言的種類永遠是第一個。例如，如果 port 安裝
              日語的 X11 字型，那 <makevar>CATEGORIES</makevar>
                那行應是 <literal>japanese x11-fonts</literal>。</para>
          </listitem>

          <listitem>
            <para>指定種類的勝過缺乏指定的。舉個例，一個 HTML 編輯器應該列成
              <literal>www editors</literal>，而不是相反過來的方式。
              同樣地，當 port 屬於 <literal>irc</literal>，
              <literal>mail</literal>，<literal>mbone</literal>，
              <literal>news</literal>，<literal>security</literal>，
              或 <literal>www</literal> 其中之一時，便不需要列出
              <literal>net</literal>。</para>
          </listitem>

          <listitem>
            <para>只有當首要的種類是母語時 <literal>x11</literal>
              才可當作第二個種類。X 的應用程式特別不該把 <literal>x11</literal>
              放進種類那行。</para>
          </listitem>

          <listitem>
            <para><application>Emacs</application>
              的模組應該和其支援的應用程式放在同一個種類裡，
              而不是<filename>editors</filename>。例如，
              用來編輯某些程式語言的原始檔的 <application>Emacs</application>
              模組就應該在 <filename>lang</filename> 裡。
              </para>
          </listitem>

          <listitem>
            <para>如果 port 真的不屬於任何地方，就把它放在
              <literal>misc</literal>。</para>
          </listitem>
        </itemizedlist>

        <para>如果不確定是何種類，請在送出的 <command>send-pr</command>
          裡附上一段註釋說明，以便我們可以在把它輸入前討論討論。
          (如果你是 committer，寄上一份備忘錄到 &a.ports;，
          這樣我們可以先討論它&mdash;新的 port
          往往被輸入到錯誤的種類結果被立刻移走。)</para>
      </sect3>
    </sect2>

    <sect2>
      <title>對這份文件和 ports 系統的改變</title>

      <para>如果你維護大量的 port，應該考慮跟著&a.ports;。對 port
        的運作的重要改變都會在這裡公告。你永遠可以在 <ulink
          url="http://www.FreeBSD.org/cgi/cvsweb.cgi/ports/Mk/bsd.port.mk"> the
          bsd.port.mk CVS log</ulink> 找到最新的變動的詳細資訊。</para>
    </sect2>

    <sect2>
      <title>各位同胞們，就這樣了！</title>

      <para>哇，這段說明真是長，不是嗎？真的感謝各位跟我們走到這邊。
        現在你知道如何做一個 port 並把世界上每個東西轉換到 port 裡了！
        這是開始對 FreeBSD Project 做出貢獻最簡單的方式！
        <!-- smiley --><emphasis>:-)</emphasis></para>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil 
     sgml-always-quote-attributes: t 
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End: 
-->
